<?php

namespace App\Http\Controllers;

use App\Models\ServiceOrder;
use App\Models\Client;
use App\Models\Receivable;
use App\Models\ServiceOrderItem;
use App\Models\ServiceOrderAttachment;
use App\Models\ServiceOrderStatusLog;
use App\Models\ServiceOrderOccurrence;
use App\Models\StockMovement;
use App\Models\Product;
use App\Models\User;
use App\Models\SmtpConfig;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\URL;
use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\Exception as PHPMailerException;

class ServiceOrderController extends Controller
{
    public function index(Request $request)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.view'), 403);

        $query = ServiceOrder::where('tenant_id', auth()->user()->tenant_id)
            ->with(['client', 'technician', 'createdBy']);

        // Filtros
        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }
        
        if ($request->filled('client_id')) {
            $query->where('client_id', $request->client_id);
        }

        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function($q) use ($search) {
                $q->where('number', 'like', "%{$search}%")
                  ->orWhere('title', 'like', "%{$search}%")
                  ->orWhere('description', 'like', "%{$search}%")
                  ->orWhereHas('client', function($clientQuery) use ($search) {
                      $clientQuery->where('name', 'like', "%{$search}%");
                  });
            });
        }
        
        // Ordenação
        $sortField = $request->get('sort', 'created_at');
        $sortDirection = $request->get('direction', 'desc');
        $query->orderBy($sortField, $sortDirection);
        
        $serviceOrders = $query->paginate(25);
        $clients = Client::where('tenant_id', auth()->user()->tenant_id)->orderBy('name')->get();
        
        return view('service_orders.index', compact('serviceOrders', 'clients'));
    }

    public function create()
    {
        abort_unless(auth()->user()->hasPermission('service_orders.create'), 403);
        
        $clients = Client::where('tenant_id', auth()->user()->tenant_id)
            ->orderBy('name')
            ->get();
        
        $technicians = User::where('tenant_id', auth()->user()->tenant_id)
            ->orderBy('name')
            ->get();
        
        return view('service_orders.create', compact('clients', 'technicians'));
    }

    public function store(Request $request)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.create'), 403);

        $validated = $request->validate([
            'client_id' => 'required|exists:clients,id',
            'title' => 'required|string|max:255',
            'description' => 'required|string|max:2000',
            'equipment_brand' => 'nullable|string|max:100',
            'equipment_model' => 'nullable|string|max:100',
            'equipment_serial' => 'nullable|string|max:100',
            'equipment_description' => 'nullable|string|max:500',
            'defect_reported' => 'nullable|string|max:1000',
            'received_by_user_id' => 'nullable|exists:users,id',
            'internal_notes' => 'nullable|string|max:2000',
            'technician_user_id' => 'nullable|exists:users,id',
            'warranty_days' => 'nullable|integer|min:0|max:3650',
            'issue_nfse' => 'boolean',
            // fotos (até 10)
            'photos' => 'nullable|array|max:10',
            'photos.*' => 'file|image|mimes:jpg,jpeg,png,webp|max:5120',
        ], [
            'client_id.required' => 'O cliente é obrigatório.',
            'client_id.exists' => 'Cliente selecionado não existe.',
            'title.required' => 'O título é obrigatório.',
            'title.max' => 'O título não pode ter mais de 255 caracteres.',
            'description.required' => 'A descrição é obrigatória.',
            'description.max' => 'A descrição não pode ter mais de 2000 caracteres.',
            'received_by_user_id.exists' => 'Usuário selecionado não existe.',
            'technician_user_id.exists' => 'Técnico selecionado não existe.',
            'warranty_days.integer' => 'Os dias de garantia devem ser um número inteiro.',
            'warranty_days.min' => 'Os dias de garantia não podem ser negativos.',
            'warranty_days.max' => 'Os dias de garantia não podem exceder 10 anos.',
        ]);
        
        // Gerar número da OS
        $lastOrder = ServiceOrder::where('tenant_id', auth()->user()->tenant_id)
            ->orderBy('number', 'desc')
                ->first();
        $nextNumber = $lastOrder ? str_pad($lastOrder->number + 1, 6, '0', STR_PAD_LEFT) : '000001';
        
        $serviceOrder = ServiceOrder::create([
            'tenant_id' => auth()->user()->tenant_id,
            'client_id' => $validated['client_id'],
            'number' => $nextNumber,
            'title' => $validated['title'],
            'description' => $validated['description'],
            'equipment_brand' => $validated['equipment_brand'] ?? null,
            'equipment_model' => $validated['equipment_model'] ?? null,
            'equipment_serial' => $validated['equipment_serial'] ?? null,
            'equipment_description' => $validated['equipment_description'] ?? null,
            'defect_reported' => $validated['defect_reported'] ?? null,
            'received_by_user_id' => $validated['received_by_user_id'] ?? null,
            'internal_notes' => $validated['internal_notes'] ?? null,
            'technician_user_id' => $validated['technician_user_id'] ?? null,
            'status' => 'open',
            'total_amount' => 0,
            'discount_total' => 0,
            'addition_total' => 0,
            'warranty_days' => $validated['warranty_days'] ?? 90,
            'issue_nfse' => $validated['issue_nfse'] ?? false,
            'created_by' => auth()->id(),
        ]);
        
        // Processar fotos se enviadas
        $photos = $request->file('photos', []);
        if (is_array($photos) && count($photos) > 0) {
            $countSaved = 0;
            foreach ($photos as $file) {
                if ($countSaved >= 10) { break; }
                if (!$file) { continue; }
                $path = $file->store('service_orders/'.$serviceOrder->id, 'public');
                \App\Models\ServiceOrderAttachment::create([
                    'tenant_id' => auth()->user()->tenant_id,
                    'service_order_id' => $serviceOrder->id,
                    'path' => $path,
                    'original_name' => $file->getClientOriginalName(),
                    'mime_type' => $file->getClientMimeType(),
                    'size' => $file->getSize(),
                ]);
                $countSaved++;
            }
        }
        
        return redirect()->route('service_orders.show', $serviceOrder)
            ->with('success', 'OS criada com sucesso!');
    }

    public function show(ServiceOrder $serviceOrder)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.view'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);
        
        // Carregar relacionamentos para auditoria
        $serviceOrder->load(['client', 'createdBy', 'updatedBy', 'quotedBy', 'technician', 'attachments', 'items', 'receivables', 'statusLogs', 'occurrences.createdBy', 'deliveredBy', 'finalizedBy']);
        
        return view('service_orders.show', compact('serviceOrder'));
    }

    public function edit(ServiceOrder $serviceOrder)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.edit'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);
        
        $clients = Client::where('tenant_id', auth()->user()->tenant_id)
            ->orderBy('name')
            ->get();
        
        $technicians = User::where('tenant_id', auth()->user()->tenant_id)
            ->orderBy('name')
            ->get(['id', 'name']);
        
        $serviceOrder->load(['items', 'technician', 'attachments']);
        
        return view('service_orders.edit', compact('serviceOrder', 'clients', 'technicians'));
    }

    public function update(Request $request, ServiceOrder $serviceOrder)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.edit'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);

        try {
        $validated = $request->validate([
            'client_id' => 'required|exists:clients,id',
            'title' => 'required|string|max:255',
                'description' => 'required|string|max:2000',
            'equipment_brand' => 'nullable|string|max:100',
            'equipment_model' => 'nullable|string|max:100',
            'equipment_serial' => 'nullable|string|max:100',
                'equipment_description' => 'nullable|string|max:500',
                'defect_reported' => 'nullable|string|max:1000',
                'received_by_user_id' => 'nullable|exists:users,id',
                'internal_notes' => 'nullable|string|max:2000',
            'technician_user_id' => 'nullable|exists:users,id',
                'status' => 'required|in:open,in_progress,in_service,service_finished,warranty,no_repair,finished,canceled',
                'diagnosis' => 'nullable|string|max:2000',
                'budget_amount' => 'nullable|numeric|min:0',
                'total_amount' => 'nullable|numeric|min:0',
                'warranty_days' => 'nullable|integer|min:0|max:3650',
                'issue_nfse' => 'boolean',
                // fotos (até 10)
                'photos' => 'nullable|array|max:10',
                'photos.*' => 'file|image|mimes:jpg,jpeg,png,webp|max:5120',
            ], [
                'client_id.required' => 'O cliente é obrigatório.',
                'client_id.exists' => 'Cliente selecionado não existe.',
                'title.required' => 'O título é obrigatório.',
                'title.max' => 'O título não pode ter mais de 255 caracteres.',
                'description.required' => 'A descrição é obrigatória.',
                'description.max' => 'A descrição não pode ter mais de 2000 caracteres.',
                'received_by_user_id.exists' => 'Usuário selecionado não existe.',
                'technician_user_id.exists' => 'Técnico selecionado não existe.',
                'status.required' => 'O status é obrigatório.',
                'status.in' => 'Status inválido.',
                'budget_amount.numeric' => 'O valor do orçamento deve ser um número válido.',
                'budget_amount.min' => 'O valor do orçamento não pode ser negativo.',
                'total_amount.numeric' => 'O valor total deve ser um número válido.',
                'total_amount.min' => 'O valor total não pode ser negativo.',
                'warranty_days.integer' => 'Os dias de garantia devem ser um número inteiro.',
                'warranty_days.min' => 'Os dias de garantia não podem ser negativos.',
                'warranty_days.max' => 'Os dias de garantia não podem exceder 10 anos.',
            ]);

        $updates = [
            'client_id' => $validated['client_id'],
            'title' => $validated['title'],
                'description' => $validated['description'],
                'equipment_brand' => $validated['equipment_brand'],
                'equipment_model' => $validated['equipment_model'],
                'equipment_serial' => $validated['equipment_serial'],
                'equipment_description' => $validated['equipment_description'],
                'defect_reported' => $validated['defect_reported'],
                'received_by_user_id' => $validated['received_by_user_id'] ?? null,
                'internal_notes' => $validated['internal_notes'] ?? null,
                'technician_user_id' => $validated['technician_user_id'] ?? null,
            'status' => $validated['status'],
                'diagnosis' => $validated['diagnosis'] ?? null,
                'budget_amount' => $validated['budget_amount'] ?? null,
                'total_amount' => $validated['total_amount'] ?? $serviceOrder->total_amount,
                'warranty_days' => $validated['warranty_days'] ?? 90,
                'issue_nfse' => $validated['issue_nfse'] ?? false,
                'updated_by' => auth()->id(),
            ];
            
            // Registrar mudança de status no log
            if ($validated['status'] !== $serviceOrder->status) {
                ServiceOrderStatusLog::create([
                    'service_order_id' => $serviceOrder->id,
                    'old_status' => $serviceOrder->status,
                    'new_status' => $validated['status'],
                    'changed_by' => auth()->id(),
                    'changed_at' => now(),
                    'reason' => $request->input('status_change_reason')
                ]);
            }
            
            // Recalcula orçamento (budget) e total a partir dos itens
            $itemsTotal = (float) $serviceOrder->items()->sum('line_total');
            $updates['budget_amount'] = $itemsTotal;
            if (!isset($validated['total_amount']) || $validated['total_amount'] === null) {
                $updates['total_amount'] = $itemsTotal;
            }
            
            // Registrar orçamento se mudou para "in_progress"
            if ($validated['status'] === 'in_progress' && $serviceOrder->status !== 'in_progress') {
                $updates['quoted_by'] = auth()->id();
                $updates['quoted_at'] = now();
            }
            
        $serviceOrder->update($updates);
        
        // Processar fotos se enviadas
        $photos = $request->file('photos', []);
        \Log::info("Fotos recebidas no update: " . count($photos));
        if (is_array($photos) && count($photos) > 0) {
            $countSaved = 0;
            foreach ($photos as $file) {
                if ($countSaved >= 10) { break; }
                if (!$file) { continue; }
                \Log::info("Processando foto: " . $file->getClientOriginalName());
                $path = $file->store('service_orders/'.$serviceOrder->id, 'public');
                \App\Models\ServiceOrderAttachment::create([
                    'tenant_id' => auth()->user()->tenant_id,
                    'service_order_id' => $serviceOrder->id,
                    'path' => $path,
                    'original_name' => $file->getClientOriginalName(),
                    'mime_type' => $file->getClientMimeType(),
                    'size' => $file->getSize(),
                ]);
                $countSaved++;
                \Log::info("Foto salva: {$path}");
            }
        }

            return redirect()->route('service_orders.edit', $serviceOrder)
                ->with('success', 'OS atualizada com sucesso!');
                
        } catch (\Exception $e) {
            return redirect()->back()
                ->with('error', 'Erro ao atualizar OS: ' . $e->getMessage())
                ->withInput();
        }
    }

    public function print(ServiceOrder $serviceOrder)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.view'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);
        $serviceOrder->load(['client', 'items', 'tenant']);
        return view('service_orders.print', ['order' => $serviceOrder]);
    }

    public function emailForm(ServiceOrder $serviceOrder)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.email'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);
        
        $client = $serviceOrder->client;
        return view('service_orders.email', compact('serviceOrder', 'client'));
    }

    public function sendEmail(Request $request, ServiceOrder $serviceOrder)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.email'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);

        $data = $request->validate([
            'to' => 'required|email|max:255',
            'subject' => 'required|string|max:255',
            'body' => 'nullable|string',
            'template' => 'nullable|in:approval_request,ready_for_pickup',
        ], [
            'to.required' => 'O campo email é obrigatório.',
            'to.email' => 'Por favor, insira um email válido.',
            'to.max' => 'O email não pode ter mais de 255 caracteres.',
            'subject.required' => 'O campo assunto é obrigatório.',
            'subject.max' => 'O assunto não pode ter mais de 255 caracteres.',
            'template.in' => 'Template selecionado é inválido.',
        ]);

        $client = $serviceOrder->client;
        if (!empty($data['template']) && (empty($client->email) || !filter_var($client->email, FILTER_VALIDATE_EMAIL))) {
            return back()->withErrors(['to' => 'O cliente não possui um email válido cadastrado. Verifique os dados do cliente.'])->withInput();
        }

        $active = SmtpConfig::where('is_active', true)->first();
        if (!$active && !env('MAIL_HOST')) {
            return back()->withErrors(['email' => 'Configuração SMTP não encontrada. Entre em contato com o administrador.'])->withInput();
        }

        $host = $active->smtp_host ?? env('MAIL_HOST');
        $port = $active->smtp_port ?? env('MAIL_PORT', 587);
        $username = $active->smtp_username ?? env('MAIL_USERNAME');
        $password = $active->smtp_password ?? env('MAIL_PASSWORD');
        $fromAddress = $active->from_address ?? env('MAIL_FROM_ADDRESS');
        $fromName = $active->from_name ?? env('MAIL_FROM_NAME', 'QFiscal');

        if (empty($host) || empty($fromAddress)) {
            return back()->withErrors(['email' => 'Configuração SMTP incompleta. Verifique host e email remetente.'])->withInput();
        }

        try {
            $mail = new PHPMailer(true);
            $mail->isSMTP();
            $mail->Host = $host;
            $mail->SMTPAuth = true;
            $mail->Username = $username;
            $mail->Password = $password;
            $mail->SMTPSecure = PHPMailer::ENCRYPTION_STARTTLS;
            $mail->Port = $port;
            $mail->CharSet = 'UTF-8';

            $mail->setFrom($fromAddress, $fromName);
            $mail->addAddress($data['to']);

            $mail->isHTML(true);
            $mail->Subject = $data['subject'];
            $mail->Body = $data['body'] ?? '';

            $mail->send();
        } catch (PHPMailerException $e) {
            $errorMessage = 'Erro ao enviar email. ';
            if (strpos($e->getMessage(), 'SMTP connect() failed') !== false) {
                $errorMessage .= 'Não foi possível conectar ao servidor de email. Verifique as configurações SMTP.';
            } elseif (strpos($e->getMessage(), 'Authentication failed') !== false) {
                $errorMessage .= 'Falha na autenticação. Verifique usuário e senha SMTP.';
            } elseif (strpos($e->getMessage(), 'Invalid address') !== false) {
                $errorMessage .= 'Email de destino inválido.';
            } elseif (strpos($e->getMessage(), 'timeout') !== false) {
                $errorMessage .= 'Timeout na conexão. Tente novamente em alguns minutos.';
            } else {
                $errorMessage .= 'Erro interno. Tente novamente ou entre em contato com o suporte.';
            }
            return back()->withErrors(['email' => $errorMessage])->withInput();
        }
        
        return redirect()->route('service_orders.show', $serviceOrder)->with('success', 'E-mail enviado com sucesso para ' . $data['to'] . '!');
    }

    public function addOccurrence(Request $request, ServiceOrder $serviceOrder)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.edit'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);

        $validated = $request->validate([
            'occurrence_type' => 'required|in:client_contact,status_change,technical_note,warranty_issue,delivery_note,payment_note,other',
            'description' => 'required|string|max:2000',
            'priority' => 'required|in:low,medium,high,urgent',
        ], [
            'occurrence_type.required' => 'O tipo de ocorrência é obrigatório.',
            'occurrence_type.in' => 'Tipo de ocorrência inválido.',
            'description.required' => 'A descrição da ocorrência é obrigatória.',
            'description.max' => 'A descrição não pode ter mais de 2000 caracteres.',
            'priority.required' => 'A prioridade é obrigatória.',
            'priority.in' => 'Prioridade inválida.',
        ]);

        // Converter checkbox para boolean (não validar, apenas converter)
        $isInternal = $request->has('is_internal') && $request->input('is_internal') === 'on';

        $occurrence = ServiceOrderOccurrence::create([
                    'service_order_id' => $serviceOrder->id,
            'occurrence_type' => $validated['occurrence_type'],
            'description' => $validated['description'],
            'created_by' => auth()->id(),
            'priority' => $validated['priority'],
            'is_internal' => $isInternal,
        ]);

        return response()->json([
            'success' => true,
            'message' => 'Ocorrência adicionada com sucesso!',
            'occurrence' => [
                'id' => $occurrence->id,
                'type' => $occurrence->occurrence_type_name,
                'description' => $occurrence->description,
                'priority' => $occurrence->priority_name,
                'priority_color' => $occurrence->priority_color,
                'type_color' => $occurrence->type_color,
                'is_internal' => $occurrence->is_internal,
                'created_by' => $occurrence->createdBy->name,
                'created_at' => $occurrence->created_at->format('d/m/Y H:i'),
            ]
        ]);
    }

    public function getOccurrences(ServiceOrder $serviceOrder)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.view'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);

        $occurrences = $serviceOrder->occurrences()
            ->with('createdBy')
            ->orderBy('created_at', 'desc')
            ->get()
            ->map(function ($occurrence) {
                return [
                    'id' => $occurrence->id,
                    'type' => $occurrence->occurrence_type_name,
                    'description' => $occurrence->description,
                    'priority' => $occurrence->priority_name,
                    'priority_color' => $occurrence->priority_color,
                    'type_color' => $occurrence->type_color,
                    'is_internal' => $occurrence->is_internal,
                    'created_by' => $occurrence->createdBy->name,
                    'created_at' => $occurrence->created_at->format('d/m/Y H:i'),
                ];
            });

        return response()->json([
            'success' => true,
            'occurrences' => $occurrences
        ]);
    }

    // ===== MÉTODOS PARA FINALIZAÇÃO =====
    
    public function finalizeForm(ServiceOrder $serviceOrder)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.finalize'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);
        
        // Não permitir finalizar OS já finalizada
        if ($serviceOrder->status === 'finished') {
            return redirect()->route('service_orders.show', $serviceOrder)
                ->with('error', 'Esta OS já foi finalizada.');
        }
        
        // Carregar relacionamentos necessários
        $serviceOrder->load(['client', 'items', 'technician', 'deliveredBy', 'finalizedBy']);
        
        // Carregar usuários para o select de entregador
        $users = User::where('tenant_id', auth()->user()->tenant_id)
            ->orderBy('name')
            ->get(['id', 'name']);
        
        return view('service_orders.finalize', compact('serviceOrder', 'users'));
    }
    
    public function finalize(Request $request, ServiceOrder $serviceOrder)
    {
        \Log::info("Iniciando finalização da OS: {$serviceOrder->id}");
        
        abort_unless(auth()->user()->hasPermission('service_orders.finalize'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);
        
        // Não permitir finalizar OS já finalizada
        if ($serviceOrder->status === 'finished') {
            \Log::warning("Tentativa de finalizar OS já finalizada: {$serviceOrder->id}");
            return redirect()->route('service_orders.show', $serviceOrder)
                ->with('error', 'Esta OS já foi finalizada.');
        }
        
        \Log::info("Validando dados da finalização da OS: {$serviceOrder->id}");
        
        // Log dos dados recebidos para debug
        \Log::info("Dados recebidos na finalização da OS {$serviceOrder->id}: " . json_encode($request->all()));
        
        try {
            $validated = $request->validate([
            'finalization_date' => 'required|date|after_or_equal:' . $serviceOrder->created_at->format('Y-m-d'),
            'finalization_notes' => 'nullable|string|max:2000',
            'delivery_method' => 'required|in:pickup,delivery,shipping',
            'delivered_by' => 'nullable|exists:users,id',
            'client_signature' => 'nullable|string|max:500',
            'equipment_condition' => 'required|in:perfect,good,damaged',
            'accessories_included' => 'nullable|string|max:1000',
            'final_amount' => 'required|numeric|min:0',
            'payment_method' => 'required|in:cash,card,pix,transfer,boleto,mixed',
            'payment_received' => 'nullable|in:on,off,1,0,true,false',
            'installments' => 'nullable|integer|min:1|max:24',
            'entry_amount' => 'nullable|numeric|min:0',
            'entry_method' => 'nullable|in:cash,pix',
        ], [
            'finalization_date.required' => 'A data de finalização é obrigatória.',
            'finalization_date.date' => 'A data de finalização deve ser uma data válida.',
            'finalization_date.after_or_equal' => 'A data de finalização não pode ser anterior à data de criação da OS.',
            'delivery_method.required' => 'O método de entrega é obrigatório.',
            'delivery_method.in' => 'Método de entrega inválido.',
            'delivered_by.exists' => 'O usuário selecionado não existe.',
            'equipment_condition.required' => 'A condição do equipamento é obrigatória.',
            'equipment_condition.in' => 'Condição do equipamento inválida.',
            'final_amount.required' => 'O valor final é obrigatório.',
            'final_amount.numeric' => 'O valor final deve ser um número válido.',
            'final_amount.min' => 'O valor final não pode ser negativo.',
            'payment_method.required' => 'O método de pagamento é obrigatório.',
            'payment_method.in' => 'Método de pagamento inválido.',
            'installments.integer' => 'O número de parcelas deve ser um número inteiro.',
            'installments.min' => 'O número de parcelas deve ser pelo menos 1.',
            'installments.max' => 'O número de parcelas não pode exceder 24.',
            'entry_amount.numeric' => 'O valor da entrada deve ser um número válido.',
            'entry_amount.min' => 'O valor da entrada não pode ser negativo.',
            'entry_method.in' => 'Método de entrada inválido.',
        ]);
        
        } catch (\Illuminate\Validation\ValidationException $e) {
            \Log::error("Erro de validação na finalização da OS {$serviceOrder->id}: " . json_encode($e->errors()));
            return redirect()->back()
                ->withErrors($e->errors())
                ->withInput();
        } catch (\Exception $e) {
            \Log::error("Erro geral na finalização da OS {$serviceOrder->id}: " . $e->getMessage());
            return redirect()->back()
                ->with('error', 'Erro ao finalizar OS: ' . $e->getMessage())
                ->withInput();
        }
        
        // Validar se o usuário entregador pertence ao mesmo tenant
        if (!empty($validated['delivered_by'])) {
            $deliveredBy = User::find($validated['delivered_by']);
            abort_unless($deliveredBy && $deliveredBy->tenant_id === auth()->user()->tenant_id, 403);
        }
        
        // Converter checkbox para boolean
        $paymentReceivedValue = $validated['payment_received'] ?? null;
        $paymentReceived = in_array($paymentReceivedValue, ['on', '1', 'true', true], true);
        
        \Log::info("Valor do payment_received para OS {$serviceOrder->id}: " . ($paymentReceived ? 'true' : 'false'));
        
        \Log::info("Dados validados com sucesso para OS: {$serviceOrder->id}. Iniciando atualização...");
        
        // Atualizar OS com dados de finalização
        $serviceOrder->update([
            'status' => 'finished',
            'finalization_date' => $validated['finalization_date'],
            'finalization_notes' => $validated['finalization_notes'],
            'delivery_method' => $validated['delivery_method'],
            'delivered_by' => $validated['delivered_by'],
            'client_signature' => $validated['client_signature'],
            'equipment_condition' => $validated['equipment_condition'],
            'accessories_included' => $validated['accessories_included'],
            'final_amount' => $validated['final_amount'],
            'payment_method' => $validated['payment_method'],
            'payment_received' => $paymentReceived,
            'finalized_by' => auth()->id(),
            'finalized_at' => now(),
        ]);
        
        \Log::info("OS atualizada com sucesso: {$serviceOrder->id}. Registrando ocorrência...");
        
        // Registrar ocorrência de finalização
        ServiceOrderOccurrence::create([
            'service_order_id' => $serviceOrder->id,
            'occurrence_type' => 'delivery_note',
            'description' => 'OS finalizada e entregue. ' . ($validated['finalization_notes'] ?? ''),
            'created_by' => auth()->id(),
            'priority' => 'medium',
            'is_internal' => false,
        ]);
        
        \Log::info("Ocorrência registrada para OS: {$serviceOrder->id}. Processando estoque...");
        
        // Dedução automática de estoque
        $this->processStockDeduction($serviceOrder);
        
        // Processar pagamentos e criar recebíveis
        $this->processPayments($serviceOrder, $validated);
        
        \Log::info("Finalização da OS {$serviceOrder->id} concluída com sucesso!");
        
        return redirect()->route('service_orders.show', $serviceOrder)
            ->with('success', 'OS finalizada com sucesso!');
    }

    public function deliveryReceipt(ServiceOrder $serviceOrder)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.view'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);
        
        // Só permite imprimir recibo se a OS estiver finalizada
        if ($serviceOrder->status !== 'finished') {
            return redirect()->route('service_orders.show', $serviceOrder)
                ->with('error', 'Só é possível imprimir o recibo de OS finalizadas.');
        }
        
        $serviceOrder->load(['client', 'items', 'tenant', 'deliveredBy', 'finalizedBy']);
        
        return view('service_orders.delivery_receipt', compact('serviceOrder'));
    }

    public function addItem(ServiceOrder $serviceOrder, Request $request)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.edit'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);

        $data = $request->validate([
            'product_id' => 'nullable|exists:products,id',
            'name' => 'required|string|max:255',
            'description' => 'nullable|string|max:500',
            'quantity' => 'required|numeric|min:0.001',
            'unit' => 'nullable|string|max:10',
            'unit_price' => 'required|numeric|min:0',
            'discount_value' => 'nullable|numeric|min:0',
        ]);

        $lineTotal = round(($data['quantity'] * $data['unit_price']) - ($data['discount_value'] ?? 0), 2);

        $item = ServiceOrderItem::create([
            'tenant_id' => auth()->user()->tenant_id,
            'service_order_id' => $serviceOrder->id,
            'product_id' => $data['product_id'],
            'name' => $data['name'],
            'description' => $data['description'] ?? '',
            'quantity' => $data['quantity'],
            'unit' => $data['unit'],
            'unit_price' => $data['unit_price'],
            'discount_value' => $data['discount_value'] ?? 0,
            'line_total' => $lineTotal,
            'total_price' => $lineTotal,
        ]);

        // Atualizar totais da OS
        $this->updateServiceOrderTotals($serviceOrder);

        return response()->json([
            'success' => true,
            'message' => 'Item adicionado com sucesso!',
            'item' => [
                'id' => $item->id,
                'name' => $item->name,
                'description' => $item->description,
                'quantity' => $item->quantity,
                'unit' => $item->unit,
                'unit_price' => number_format($item->unit_price, 2, ',', '.'),
                'discount_value' => number_format($item->discount_value, 2, ',', '.'),
                'line_total' => number_format($item->line_total, 2, ',', '.'),
            ]
        ]);
    }

    public function removeItem(ServiceOrder $serviceOrder, ServiceOrderItem $item)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.edit'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);
        abort_unless($item->service_order_id === $serviceOrder->id, 403);

        $item->delete();

        // Atualizar totais da OS
        $this->updateServiceOrderTotals($serviceOrder);

        return response()->json([
            'success' => true,
            'message' => 'Item removido com sucesso!'
        ]);
    }

    public function publicApproval(Request $request, ServiceOrder $serviceOrder)
    {
        // Link assinado (signed route) já confere validade e integridade
        if (!$request->hasValidSignature()) {
            abort(403, 'Link inválido ou expirado.');
        }

        $action = $request->input('action');
        if (!in_array($action, ['approve', 'reject'])) {
            abort(400, 'Ação inválida.');
        }

        if ($action === 'approve') {
            $serviceOrder->update([
                'approval_status' => 'approved',
                'approved_at' => now(),
                'approved_by_email' => $request->input('email'),
                'approval_method' => 'email',
            ]);
            $message = 'OS aprovada com sucesso!';
            } else {
            $serviceOrder->update([
                'approval_status' => 'not_approved',
                'rejected_at' => now(),
                'rejected_by_email' => $request->input('email'),
                'rejection_method' => 'email',
            ]);
            $message = 'OS reprovada.';
        }

        return view('service_orders.public_response', compact('serviceOrder', 'message'));
    }

    /**
     * Processa a dedução automática de estoque ao finalizar uma OS
     */
    private function processStockDeduction(ServiceOrder $serviceOrder)
    {
        \Log::info("Iniciando processamento de estoque para OS: {$serviceOrder->id}");
        
        // Verificar se a OS tem produto associado
        if (!$serviceOrder->product_id) {
            \Log::info("OS {$serviceOrder->id} não tem produto associado (produto avulso). Pulando dedução de estoque.");
            return; // Produto avulso, não faz nada
        }

        // Buscar o produto no estoque
        $product = Product::where('id', $serviceOrder->product_id)
            ->where('tenant_id', auth()->user()->tenant_id)
            ->first();

        if (!$product) {
            return; // Produto não existe no estoque, não faz nada
        }

        // Consultar configuração "Permitir Estoque Negativo"
        $allowNegativeStock = $this->getSettingValue('allow_negative_stock', false);

        // Verificar se há estoque suficiente (se não permitir negativo)
        if (!$allowNegativeStock && $product->stock < 1) {
            // Log da tentativa de dedução sem estoque
            \Log::warning("Tentativa de dedução de estoque sem quantidade suficiente. OS: {$serviceOrder->id}, Produto: {$product->id}, Estoque atual: {$product->stock}");
            return;
        }

        // Deduzir estoque
        $product->decrement('stock', 1);

        // Registrar movimentação de estoque
        StockMovement::create([
            'tenant_id' => auth()->user()->tenant_id,
            'product_id' => $product->id,
            'service_order_id' => $serviceOrder->id,
            'movement_type' => 'out',
            'quantity' => 1,
            'reason' => 'OS Finalizada',
            'user_id' => auth()->id(),
            'notes' => "Dedução automática pela finalização da OS #{$serviceOrder->number}",
        ]);

        \Log::info("Estoque deduzido automaticamente. OS: {$serviceOrder->id}, Produto: {$product->id}, Quantidade: 1");
    }

    /**
     * Processa pagamentos e cria recebíveis conforme método de pagamento
     */
    private function processPayments(ServiceOrder $serviceOrder, array $validated)
    {
        \Log::info("Iniciando processamento de pagamentos para OS: {$serviceOrder->id}");
        
        $paymentMethod = $validated['payment_method'];
        $finalAmount = $validated['final_amount'];
        $paymentReceived = $this->convertPaymentReceived($validated['payment_received'] ?? null);
        
        // Buscar configurações de OS
        $maxInstallments = (int) $this->getSettingValue('os_max_installments', 3);
        $interestRate = (float) $this->getSettingValue('os_interest_rate', 0);
        
        switch ($paymentMethod) {
            case 'cash':
                $this->processCashPayment($serviceOrder, $finalAmount, $paymentReceived);
                break;
                
            case 'card':
                $installments = $validated['installments'] ?? 1;
                $this->processCardPayment($serviceOrder, $finalAmount, $installments, $interestRate, $paymentReceived);
                break;
                
            case 'pix':
                $this->processPixPayment($serviceOrder, $finalAmount, $paymentReceived);
                break;
                
            case 'transfer':
                $this->processTransferPayment($serviceOrder, $finalAmount, $paymentReceived);
                break;
                
            case 'boleto':
                $this->processBoletoPayment($serviceOrder, $finalAmount);
                break;
                
            case 'mixed':
                $entryAmount = $validated['entry_amount'] ?? 0;
                $entryMethod = $validated['entry_method'] ?? 'cash';
                $installments = $validated['installments'] ?? 1;
                $this->processMixedPayment($serviceOrder, $finalAmount, $entryAmount, $entryMethod, $installments, $interestRate, $paymentReceived);
                break;
        }
        
        // Marcar que recebíveis foram criados
        $serviceOrder->update([
            'receivables_created' => true,
            'receivables_created_at' => now(),
        ]);
        
        \Log::info("Processamento de pagamentos concluído para OS: {$serviceOrder->id}");
    }

    /**
     * Processa pagamento em dinheiro
     */
    private function processCashPayment(ServiceOrder $serviceOrder, $amount, $received)
    {
        if ($received) {
            // Criar recebível pago
            \App\Models\Receivable::create([
                'tenant_id' => auth()->user()->tenant_id,
                'client_id' => $serviceOrder->client_id,
                'service_order_id' => $serviceOrder->id,
                'description' => "OS #{$serviceOrder->number} - Pagamento à vista",
                'amount' => $amount,
                'due_date' => now()->toDateString(),
                'status' => 'paid',
                'received_at' => now(),
                'payment_method' => 'cash',
                'created_by' => auth()->id(),
            ]);
            
            // Adicionar ao caixa do dia
            $this->addToDailyCash($amount, 'OS #' . $serviceOrder->number);
        }
    }

    /**
     * Processa pagamento no cartão
     */
    private function processCardPayment(ServiceOrder $serviceOrder, $amount, $installments, $interestRate, $received)
    {
        $totalWithInterest = $this->calculateTotalWithInterest($amount, $installments, $interestRate);
        $interestAmount = $totalWithInterest - $amount;
        $installmentAmount = round($totalWithInterest / $installments, 2);
        
        // Atualizar OS com cálculos
        $serviceOrder->update([
            'installments' => $installments,
            'interest_rate' => $interestRate,
            'interest_amount' => $interestAmount,
            'total_with_interest' => $totalWithInterest,
        ]);
        
        // Criar recebíveis
        $firstDueDate = now()->addDays(30);
        for ($i = 1; $i <= $installments; $i++) {
            $dueDate = $firstDueDate->copy()->addDays(($i - 1) * 30);
            $status = ($i === 1 && $received) ? 'paid' : 'open';
            $receivedAt = ($i === 1 && $received) ? now() : null;
            
            \App\Models\Receivable::create([
                'tenant_id' => auth()->user()->tenant_id,
                'client_id' => $serviceOrder->client_id,
                'service_order_id' => $serviceOrder->id,
                'description' => "OS #{$serviceOrder->number} - Parcela {$i}/{$installments}",
                'amount' => $installmentAmount,
                'due_date' => $dueDate->toDateString(),
                'status' => $status,
                'received_at' => $receivedAt,
                'payment_method' => 'card',
                'created_by' => auth()->id(),
            ]);
            
            // Se primeira parcela foi paga, adicionar ao caixa
            if ($i === 1 && $received) {
                $this->addToDailyCash($installmentAmount, 'OS #' . $serviceOrder->number . ' - Parcela 1');
            }
        }
    }

    /**
     * Processa pagamento PIX
     */
    private function processPixPayment(ServiceOrder $serviceOrder, $amount, $received)
    {
        if ($received) {
            \App\Models\Receivable::create([
                'tenant_id' => auth()->user()->tenant_id,
                'client_id' => $serviceOrder->client_id,
                'service_order_id' => $serviceOrder->id,
                'description' => "OS #{$serviceOrder->number} - PIX",
                'amount' => $amount,
                'due_date' => now()->toDateString(),
                'status' => 'paid',
                'received_at' => now(),
                'payment_method' => 'pix',
                'created_by' => auth()->id(),
            ]);
            
            $this->addToDailyCash($amount, 'OS #' . $serviceOrder->number . ' - PIX');
        }
    }

    /**
     * Processa pagamento por transferência
     */
    private function processTransferPayment(ServiceOrder $serviceOrder, $amount, $received)
    {
        if ($received) {
            \App\Models\Receivable::create([
                'tenant_id' => auth()->user()->tenant_id,
                'client_id' => $serviceOrder->client_id,
                'service_order_id' => $serviceOrder->id,
                'description' => "OS #{$serviceOrder->number} - Transferência",
                'amount' => $amount,
                'due_date' => now()->toDateString(),
                'status' => 'paid',
                'received_at' => now(),
                'payment_method' => 'transfer',
                'created_by' => auth()->id(),
            ]);
            
            $this->addToDailyCash($amount, 'OS #' . $serviceOrder->number . ' - Transferência');
        }
    }

    /**
     * Processa pagamento por boleto
     */
    private function processBoletoPayment(ServiceOrder $serviceOrder, $amount)
    {
        \App\Models\Receivable::create([
            'tenant_id' => auth()->user()->tenant_id,
            'client_id' => $serviceOrder->client_id,
            'service_order_id' => $serviceOrder->id,
            'description' => "OS #{$serviceOrder->number} - Boleto Bancário",
            'amount' => $amount,
            'due_date' => now()->addDays(7)->toDateString(), // 7 dias para pagamento
            'status' => 'open',
            'payment_method' => 'boleto',
            'created_by' => auth()->id(),
        ]);
    }

    /**
     * Processa pagamento misto (entrada + parcelas)
     */
    private function processMixedPayment(ServiceOrder $serviceOrder, $totalAmount, $entryAmount, $entryMethod, $installments, $interestRate, $received)
    {
        // Processar entrada
        if ($entryAmount > 0) {
            if ($received) {
                \App\Models\Receivable::create([
                    'tenant_id' => auth()->user()->tenant_id,
                    'client_id' => $serviceOrder->client_id,
                    'service_order_id' => $serviceOrder->id,
                    'description' => "OS #{$serviceOrder->number} - Entrada ({$entryMethod})",
                    'amount' => $entryAmount,
                    'due_date' => now()->toDateString(),
                    'status' => 'paid',
                    'received_at' => now(),
                    'payment_method' => $entryMethod,
                    'created_by' => auth()->id(),
                ]);
                
                $this->addToDailyCash($entryAmount, 'OS #' . $serviceOrder->number . ' - Entrada');
            }
        }
        
        // Processar parcelas do restante
        $remainingAmount = $totalAmount - $entryAmount;
        if ($remainingAmount > 0) {
            $totalWithInterest = $this->calculateTotalWithInterest($remainingAmount, $installments, $interestRate);
            $interestAmount = $totalWithInterest - $remainingAmount;
            $installmentAmount = round($totalWithInterest / $installments, 2);
            
            // Atualizar OS com cálculos
            $serviceOrder->update([
                'entry_amount' => $entryAmount,
                'entry_method' => $entryMethod,
                'installments' => $installments,
                'interest_rate' => $interestRate,
                'interest_amount' => $interestAmount,
                'total_with_interest' => $totalWithInterest,
            ]);
            
            // Criar recebíveis das parcelas
            $firstDueDate = now()->addDays(30);
            for ($i = 1; $i <= $installments; $i++) {
                $dueDate = $firstDueDate->copy()->addDays(($i - 1) * 30);
                
                \App\Models\Receivable::create([
                    'tenant_id' => auth()->user()->tenant_id,
                    'client_id' => $serviceOrder->client_id,
                    'service_order_id' => $serviceOrder->id,
                    'description' => "OS #{$serviceOrder->number} - Parcela {$i}/{$installments}",
                    'amount' => $installmentAmount,
                    'due_date' => $dueDate->toDateString(),
                    'status' => 'open',
                    'payment_method' => 'card',
                    'created_by' => auth()->id(),
                ]);
            }
        }
    }

    /**
     * Calcula total com juros
     */
    private function calculateTotalWithInterest($amount, $installments, $interestRate)
    {
        if ($interestRate <= 0) {
            return $amount;
        }
        
        // Juros simples
        $interestAmount = $amount * ($interestRate / 100) * $installments;
        return $amount + $interestAmount;
    }

    /**
     * Adiciona valor ao caixa do dia
     */
    private function addToDailyCash($amount, $description)
    {
        try {
            $today = now()->toDateString();
            
            // Verificar se caixa está fechado
            if (\App\Http\Controllers\DailyCashController::isCashClosed(auth()->user()->tenant_id, $today)) {
                \Log::warning("Tentativa de adicionar ao caixa fechado: {$description}");
                return;
            }
            
            // Atualizar ou criar registro do caixa do dia
            \App\Models\DailyCash::updateOrCreate(
                [
                    'tenant_id' => auth()->user()->tenant_id,
                    'date' => $today,
                ],
                [
                    'status' => 'open',
                    'total_received' => \App\Models\Receivable::where('tenant_id', auth()->user()->tenant_id)
                        ->where('status', 'paid')
                        ->whereDate('received_at', $today)
                        ->sum('amount'),
                ]
            );
            
            \Log::info("Valor adicionado ao caixa do dia: R$ {$amount} - {$description}");
        } catch (\Exception $e) {
            \Log::error("Erro ao adicionar ao caixa do dia: " . $e->getMessage());
        }
    }

    /**
     * Converte valor do checkbox para boolean
     */
    private function convertPaymentReceived($value)
    {
        return in_array($value, ['on', '1', 'true', true], true);
    }

    /**
     * Adiciona anexo/foto à OS
     */
    public function addAttachment(ServiceOrder $serviceOrder, Request $request)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.edit'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id, 403);

        $request->validate([
            'file' => 'required|file|max:10240',
        ]);

        $file = $request->file('file');
        
        // Limitar a 10 fotos (imagens) por OS
        if (str_starts_with((string)$file->getMimeType(), 'image/')) {
            $imageCount = \App\Models\ServiceOrderAttachment::where('tenant_id', auth()->user()->tenant_id)
                ->where('service_order_id', $serviceOrder->id)
                ->where('mime_type', 'like', 'image/%')
                ->count();
            if ($imageCount >= 10) {
                return back()->with('error', 'Limite de 10 fotos por OS atingido.');
            }
        }
        
        $path = $file->store('service_orders/'. $serviceOrder->id, 'public');

        \App\Models\ServiceOrderAttachment::create([
            'tenant_id' => auth()->user()->tenant_id,
            'service_order_id' => $serviceOrder->id,
            'path' => $path,
            'original_name' => $file->getClientOriginalName(),
            'mime_type' => $file->getClientMimeType(),
            'size' => $file->getSize(),
        ]);

        return back()->with('success', 'Anexo adicionado.');
    }

    /**
     * Remove anexo/foto da OS
     */
    public function removeAttachment(ServiceOrder $serviceOrder, \App\Models\ServiceOrderAttachment $attachment)
    {
        abort_unless(auth()->user()->hasPermission('service_orders.edit'), 403);
        abort_unless($serviceOrder->tenant_id === auth()->user()->tenant_id && $attachment->service_order_id === $serviceOrder->id, 403);

        // Remover arquivo físico (se existir)
        try { 
            \Storage::disk('public')->delete($attachment->path); 
        } catch (\Throwable $e) {
            \Log::warning("Erro ao deletar arquivo físico: " . $e->getMessage());
        }
        
        $attachment->delete();
        return back()->with('success', 'Anexo removido.');
    }

    /**
     * Processa dedução de estoque para todos os itens da OS
     */
    private function processStockDeduction(ServiceOrder $serviceOrder)
    {
        \Log::info("Iniciando processamento de estoque para OS: {$serviceOrder->id}");

        // Buscar todos os itens da OS que têm produto_id
        $items = $serviceOrder->items()->whereNotNull('product_id')->get();
        
        if ($items->isEmpty()) {
            \Log::info("OS {$serviceOrder->id} não tem produtos com estoque. Pulando dedução de estoque.");
            return;
        }

        $allowNegativeStock = $this->getSettingValue('allow_negative_stock', false);

        foreach ($items as $item) {
            $product = Product::where('id', $item->product_id)
                ->where('tenant_id', auth()->user()->tenant_id)
                ->first();

            if (!$product) {
                \Log::warning("Produto {$item->product_id} não encontrado para item {$item->id}");
                continue;
            }

            if (!$allowNegativeStock && $product->stock < $item->quantity) {
                \Log::warning("Tentativa de dedução de estoque sem quantidade suficiente. OS: {$serviceOrder->id}, Produto: {$product->id}, Estoque atual: {$product->stock}, Quantidade solicitada: {$item->quantity}");
                continue;
            }

            $product->decrement('stock', $item->quantity);

            StockMovement::create([
                'tenant_id' => auth()->user()->tenant_id,
                'product_id' => $product->id,
                'service_order_id' => $serviceOrder->id,
                'movement_type' => 'out',
                'quantity' => $item->quantity,
                'reason' => 'OS Finalizada',
                'user_id' => auth()->id(),
                'notes' => "Dedução automática pela finalização da OS #{$serviceOrder->number} - Item: {$item->name}",
            ]);

            \Log::info("Estoque deduzido automaticamente. OS: {$serviceOrder->id}, Produto: {$product->id}, Quantidade: {$item->quantity}");
        }

        \Log::info("Processamento de estoque concluído para OS: {$serviceOrder->id}");
    }

    /**
     * Atualiza os totais da OS baseado nos itens
     */
    private function updateServiceOrderTotals(ServiceOrder $serviceOrder)
    {
        // Recalcular totais baseado nos itens
        $totalFromItems = $serviceOrder->items()->sum('line_total');
        
        // Atualizar budget_amount e total_amount
        $serviceOrder->budget_amount = $totalFromItems;
        
        // Em garantia ou sem reparo: total sempre zero
        if (in_array($serviceOrder->status, ['warranty', 'no_repair'], true)) {
            $serviceOrder->total_amount = 0;
        } else {
            $serviceOrder->total_amount = $totalFromItems;
        }
        
        // Ao adicionar item, sair de "Aguardando" para "Em andamento"
        if ($serviceOrder->status === 'open') {
            $serviceOrder->status = 'in_progress';
        }
        
        $serviceOrder->save();
    }

    /**
     * Busca valor de configuração do sistema
     */
    private function getSettingValue($key, $default = null)
    {
        try {
            $setting = \App\Models\Setting::where('tenant_id', auth()->user()->tenant_id)
                ->where('key', $key)
                ->first();
            
            return $setting ? $setting->value : $default;
        } catch (\Exception $e) {
            \Log::error("Erro ao buscar configuração {$key}: " . $e->getMessage());
            return $default;
        }
    }
}