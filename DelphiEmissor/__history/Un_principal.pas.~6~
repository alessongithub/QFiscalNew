unit Un_principal;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, ACBrValidador, ACBrDFeReport,
  ACBrDFeDANFeReport, ACBrNFeDANFEClass, ACBrNFeDANFeRLClass, ACBrBase, ACBrDFe,
  ACBrNFe, ACBrDFeSSL, System.NetEncoding, System.IOUtils, IdURI,
  // Indy HTTP
  IdHTTPServer, IdContext, IdCustomHTTPServer,
  // JSON
  System.JSON, ACBrNFSe, pcnConversao;

type
  TForm1 = class(TForm)
    ACBrNFe1: TACBrNFe;
    ACBrNFeDANFeRL1: TACBrNFeDANFeRL;
    ACBrValidador1: TACBrValidador;
    ACBrNFSe1: TACBrNFSe;
    procedure FormCreate(Sender: TObject);
    procedure IdHTTPServer1CommandGet(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo;
      AResponseInfo: TIdHTTPResponseInfo);
  private
    FServer: TIdHTTPServer;
    FValidTokens: TStringList;
    function ReadRequestBody(ARequestInfo: TIdHTTPRequestInfo): string;
    function EmitirNFeJSON(const JSONData: string): string;
    function CancelarNFeJSON(const JSONData: string): string;
    function CartaCorrecaoJSON(const JSONData: string): string;
    function InutilizarNFeJSON(const JSONData: string): string;
    function EmitirNFSeJSON(const JSONData: string): string;
    function JsonGetObj(Obj: TJSONObject; const Key: string): TJSONObject;
    function JsonGetArr(Obj: TJSONObject; const Key: string): TJSONArray;
    function JsonGetStr(Obj: TJSONObject; const Key: string; const Default: string = ''): string;
    function JsonGetInt(Obj: TJSONObject; const Key: string; const Default: Integer = 0): Integer;
    function ValidateToken(ARequestInfo: TIdHTTPRequestInfo): Boolean;
    function ExtractTokenFromHeader(ARequestInfo: TIdHTTPRequestInfo): string;
    procedure LogSecurityEvent(const EventType, Details: string);
    procedure LoadValidTokens;
  public
    { Public declarations }
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

function DigitsOnly(const S: string): string;
var i: Integer; ch: Char;
begin
  Result := '';
  for i := 1 to Length(S) do
  begin
    ch := S[i];
    if (ch >= '0') and (ch <= '9') then
      Result := Result + ch;
  end;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  try
    Caption := 'Inicializando ACBr...';
    ACBrNFe1.Configuracoes.WebServices.Visualizar := False;
    ACBrNFe1.Configuracoes.WebServices.Salvar := True;
    ACBrNFe1.Configuracoes.Arquivos.Salvar := True;
    ACBrNFe1.DANFE := ACBrNFeDANFeRL1;

    Caption := 'Configurando SSL...';
    ACBrNFe1.Configuracoes.Geral.SSLLib := libOpenSSL;
    ACBrNFe1.Configuracoes.Geral.SSLCryptLib := cryOpenSSL;
    ACBrNFe1.Configuracoes.Geral.SSLHttpLib := httpOpenSSL;
    //ACBrNFe1.Configuracoes.Geral.SSLXmlSignLib := xsMsXml;

    // Diretório padrão para XMLs e logs ao lado do executável
    try
      ACBrNFe1.Configuracoes.Arquivos.PathNFe := IncludeTrailingPathDelimiter(ExtractFilePath(Application.ExeName) + 'nfe');
      if not DirectoryExists(ACBrNFe1.Configuracoes.Arquivos.PathNFe) then
        ForceDirectories(ACBrNFe1.Configuracoes.Arquivos.PathNFe);
      if not DirectoryExists(ExtractFilePath(Application.ExeName) + 'logs') then
        ForceDirectories(ExtractFilePath(Application.ExeName) + 'logs');
      if not DirectoryExists(ExtractFilePath(Application.ExeName) + 'logs\\requests') then
        ForceDirectories(ExtractFilePath(Application.ExeName) + 'logs\\requests');
    except
      // ignora erros de IO aqui
    end;

    Caption := 'Inicializando tokens...';
    FValidTokens := TStringList.Create;
    LoadValidTokens;

    Caption := 'Iniciando servidor HTTP...';
    FServer := TIdHTTPServer.Create(Self);
    FServer.OnCommandGet := IdHTTPServer1CommandGet;
    FServer.Bindings.Clear;
    with FServer.Bindings.Add do
    begin
      IP := '0.0.0.0';
      Port := 18080;
    end;
    FServer.Active := True;

    Caption := 'Emissor NFe/NFS-e - Porta 18080 - Seguro [' + FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ']';
    // Grava build_info para confirmar a versão em execução
    try
      var LogDir := ExtractFilePath(Application.ExeName) + 'logs\\';
      if not DirectoryExists(LogDir) then ForceDirectories(LogDir);
      var F: TextFile;
      AssignFile(F, LogDir + 'build_info.txt');
      Rewrite(F);
      try
        Writeln(F, 'started_at=' + FormatDateTime('yyyy-mm-dd hh:nn:ss', Now));
        Writeln(F, 'features=impostos_no_item;status_ext;payload_logs');
        Writeln(F, 'exe=' + Application.ExeName);
      finally
        CloseFile(F);
      end;
    except
    end;
    LogSecurityEvent('STARTUP', 'Emissor iniciado com sistema de segurança');
  except
    on E: Exception do
    begin
      ShowMessage('Erro no FormCreate: ' + E.Message + sLineBreak + 'Caption atual: ' + Caption);
      Caption := 'Emissor - erro';
    end;
  end;
end;



function TForm1.ReadRequestBody(ARequestInfo: TIdHTTPRequestInfo): string;
var
  ss: TStringStream;
begin
  Result := '';
  if Assigned(ARequestInfo.PostStream) then
  begin
    ss := TStringStream.Create('', TEncoding.UTF8);
    try
      ARequestInfo.PostStream.Position := 0;
      ss.CopyFrom(ARequestInfo.PostStream, ARequestInfo.PostStream.Size);
      Result := ss.DataString;
    finally
      ss.Free;
    end;
  end
  else
    Result := ARequestInfo.UnparsedParams;
end;

procedure TForm1.IdHTTPServer1CommandGet(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo;
  AResponseInfo: TIdHTTPResponseInfo);
var
  Path, Body, Resp: string;
begin
  // CORS básico
  AResponseInfo.CustomHeaders.Values['Access-Control-Allow-Origin'] := '*';
  AResponseInfo.CustomHeaders.Values['Access-Control-Allow-Methods'] := 'GET, POST, OPTIONS';
  AResponseInfo.CustomHeaders.Values['Access-Control-Allow-Headers'] := 'Content-Type, Authorization';

  if SameText(ARequestInfo.Command, 'OPTIONS') then
  begin
    AResponseInfo.ResponseNo := 200;
    Exit;
  end;

  Path := LowerCase(ARequestInfo.Document);
  
  // Endpoint público (sem autenticação)
  if (ARequestInfo.Command = 'GET') and (Path = '/api/status') then
  begin
    AResponseInfo.ResponseNo := 200;
    AResponseInfo.ContentType := 'application/json';
    AResponseInfo.ContentText := '{"ok":true,"message":"Emissor ativo","cert_ok":true}';
    Exit;
  end;

  // Endpoints protegidos (requerem autenticação)
  if (ARequestInfo.Command = 'POST') and (Path = '/api/emitir-nfe') then
  begin
    if not ValidateToken(ARequestInfo) then
    begin
      AResponseInfo.ResponseNo := 401;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := '{"error":"Token de autenticação inválido ou ausente"}';
      LogSecurityEvent('AUTH_FAILED', 'Tentativa de emissão NFe sem token válido - IP: ' + AContext.Binding.PeerIP);
      Exit;
    end;
    
    Body := ReadRequestBody(ARequestInfo);
    // Fallbacks: aceitar JSON via query (json/urlencode) ou base64
    if (Body = '') then
    begin
      try
        var QJson := ARequestInfo.Params.Values['json'];
        if QJson <> '' then
          Body := TIdURI.URLDecode(QJson);
      except end;
      if (Body = '') then
      begin
        try
          var QB64 := ARequestInfo.Params.Values['b64'];
          if QB64 <> '' then
            Body := TEncoding.UTF8.GetString(TNetEncoding.Base64.DecodeStringToBytes(QB64));
        except end;
      end;
    end;
    // Salva payload recebido (debug)
    try
      var LogDir := ExtractFilePath(Application.ExeName) + 'logs\\requests\\';
      var Name := Format('emitir-nfe-%s.json', [FormatDateTime('yyyymmdd-hhnnss-zzz', Now)]);
      var Full := LogDir + Name;
      var F: TextFile;
      AssignFile(F, Full);
      Rewrite(F);
      try
        Writeln(F, Body);
      finally
        CloseFile(F);
      end;
    except
      // ignora erros de IO
    end;
    Resp := EmitirNFeJSON(Body);
    AResponseInfo.ResponseNo := 200;
    AResponseInfo.ContentType := 'application/json';
    AResponseInfo.ContentText := Resp;
    LogSecurityEvent('NFE_EMIT', 'NFe emitida com sucesso - IP: ' + AContext.Binding.PeerIP);
    Exit;
  end;

  if (ARequestInfo.Command = 'POST') and (Path = '/api/cancelar-nfe') then
  begin
    if not ValidateToken(ARequestInfo) then
    begin
      AResponseInfo.ResponseNo := 401;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := '{"error":"Token de autenticação inválido ou ausente"}';
      LogSecurityEvent('AUTH_FAILED', 'Tentativa de cancelamento NFe sem token válido - IP: ' + AContext.Binding.PeerIP);
      Exit;
    end;
    
    Body := ReadRequestBody(ARequestInfo);
    Resp := CancelarNFeJSON(Body);
    AResponseInfo.ResponseNo := 200;
    AResponseInfo.ContentType := 'application/json';
    AResponseInfo.ContentText := Resp;
    LogSecurityEvent('NFE_CANCEL', 'NFe cancelada com sucesso - IP: ' + AContext.Binding.PeerIP);
    Exit;
  end;

  if (ARequestInfo.Command = 'POST') and (Path = '/api/carta-correcao') then
  begin
    if not ValidateToken(ARequestInfo) then
    begin
      AResponseInfo.ResponseNo := 401;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := '{"error":"Token de autenticação inválido ou ausente"}';
      LogSecurityEvent('AUTH_FAILED', 'Tentativa de carta correção sem token válido - IP: ' + AContext.Binding.PeerIP);
      Exit;
    end;
    
    Body := ReadRequestBody(ARequestInfo);
    Resp := CartaCorrecaoJSON(Body);
    AResponseInfo.ResponseNo := 200;
    AResponseInfo.ContentType := 'application/json';
    AResponseInfo.ContentText := Resp;
    LogSecurityEvent('NFE_CCE', 'Carta de correção emitida com sucesso - IP: ' + AContext.Binding.PeerIP);
    Exit;
  end;

  if (ARequestInfo.Command = 'POST') and (Path = '/api/inutilizar-nfe') then
  begin
    if not ValidateToken(ARequestInfo) then
    begin
      AResponseInfo.ResponseNo := 401;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := '{"error":"Token de autenticação inválido ou ausente"}';
      LogSecurityEvent('AUTH_FAILED', 'Tentativa de inutilização NFe sem token válido - IP: ' + AContext.Binding.PeerIP);
      Exit;
    end;
    
    Body := ReadRequestBody(ARequestInfo);
    Resp := InutilizarNFeJSON(Body);
    AResponseInfo.ResponseNo := 200;
    AResponseInfo.ContentType := 'application/json';
    AResponseInfo.ContentText := Resp;
    LogSecurityEvent('NFE_INUTIL', 'NFe inutilizada com sucesso - IP: ' + AContext.Binding.PeerIP);
    Exit;
  end;

  if (ARequestInfo.Command = 'POST') and (Path = '/api/emitir-nfse') then
  begin
    if not ValidateToken(ARequestInfo) then
    begin
      AResponseInfo.ResponseNo := 401;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := '{"error":"Token de autenticação inválido ou ausente"}';
      LogSecurityEvent('AUTH_FAILED', 'Tentativa de emissão NFSe sem token válido - IP: ' + AContext.Binding.PeerIP);
      Exit;
    end;
    
    Body := ReadRequestBody(ARequestInfo);
    Resp := EmitirNFSeJSON(Body);
    AResponseInfo.ResponseNo := 200;
    AResponseInfo.ContentType := 'application/json';
    AResponseInfo.ContentText := Resp;
    LogSecurityEvent('NFSE_EMIT', 'NFSe emitida com sucesso - IP: ' + AContext.Binding.PeerIP);
    Exit;
  end;

  AResponseInfo.ResponseNo := 404;
  AResponseInfo.ContentType := 'application/json';
  AResponseInfo.ContentText := '{"ok":false,"error":"endpoint not found"}';
end;

function TForm1.EmitirNFSeJSON(const JSONData: string): string;
var
  J, Prestador, Tomador, Rps, Servico: TJSONObject;
  Resp: TJSONObject;
begin
  Resp := TJSONObject.Create;
  try
    try
      J := TJSONObject(TJSONObject.ParseJSONValue(JSONData));
      if not Assigned(J) then
        raise Exception.Create('JSON inválido');

      Prestador := JsonGetObj(J, 'prestador');
      Tomador := JsonGetObj(J, 'tomador');
      Rps := JsonGetObj(J, 'rps');
      Servico := JsonGetObj(J, 'servico');

      if (Prestador = nil) or (Tomador = nil) or (Rps = nil) or (Servico = nil) then
        raise Exception.Create('Campos obrigatórios ausentes (prestador, tomador, rps, servico)');

      // Implementação mínima para validar fluxo. A implementação completa de ACBrNFSe
      // varia conforme provedor e versão. Aqui confirmamos recebimento e retornamos OK.

      Resp.AddPair('ok', TJSONBool.Create(True));
      Resp.AddPair('message', 'NFSe endpoint online. Implementação completa depende do provedor.');
    except
      on E: Exception do
      begin
        Resp.AddPair('ok', TJSONBool.Create(False));
        Resp.AddPair('error', E.Message);
      end;
    end;
    Result := Resp.ToString;
  finally
    Resp.Free;
  end;
end;

function TForm1.InutilizarNFeJSON(const JSONData: string): string;
var
  J: TJSONObject;
  Resp: TJSONObject;
  emitCNPJ, justificativa: string;
  ano, modelo, serie, nIni, nFim: Integer;
  retXML: string;
begin
  Resp := TJSONObject.Create;
  try
    try
      J := TJSONObject(TJSONObject.ParseJSONValue(JSONData));
      if not Assigned(J) then
        raise Exception.Create('JSON inválido');

      emitCNPJ := JsonGetStr(J, 'emit_cnpj', '');
      justificativa := JsonGetStr(J, 'justificativa', '');
      if Length(justificativa) < 15 then
        raise Exception.Create('Justificativa deve ter no mínimo 15 caracteres');

      ano := JsonGetInt(J, 'ano', StrToInt(FormatDateTime('yy', Now)));
      modelo := JsonGetInt(J, 'modelo', 55);
      serie := JsonGetInt(J, 'serie', 1);
      nIni := JsonGetInt(J, 'numero_inicial', 0);
      nFim := JsonGetInt(J, 'numero_final', nIni);

      ACBrNFe1.Inutilizar(emitCNPJ, justificativa, ano, modelo, serie, nIni);
      try
        retXML := ACBrNFe1.WebServices.Inutilizacao.RetWS;
      except
        retXML := '';
      end;

      Resp.AddPair('ok', TJSONBool.Create(True));
      if retXML <> '' then Resp.AddPair('xml_retorno', retXML);
    except
      on E: Exception do
      begin
        Resp.AddPair('ok', TJSONBool.Create(False));
        Resp.AddPair('error', E.Message);
      end;
    end;
    Result := Resp.ToString;
  finally
    Resp.Free;
  end;
end;

function TForm1.EmitirNFeJSON(const JSONData: string): string;
var
  J, EmitObj, DestObj, Conf, ItemObj: TJSONObject;
  Itens: TJSONArray;
  i: Integer;
  XMLPath, PDFPath, Protocolo, Chave: string;
  Resp: TJSONObject;
  PreXMLPath: string;
  BuildPhase: string;
  DebugXML: string;
  TmpXMLPath: string;
  JSONText: string;
  function FileToBase64(const APath: string): string;
  var bytes: TBytes;
  begin
    Result := '';
    try
      if (APath <> '') and FileExists(APath) then
      begin
        bytes := TFile.ReadAllBytes(APath);
        Result := TNetEncoding.Base64.EncodeBytesToString(bytes);
      end;
    except
      Result := '';
    end;
  end;
  procedure AttachPreXMLBase64;
  var TempPath, Tmp: string;
  begin
    try
      if ACBrNFe1.NotasFiscais.Count = 0 then Exit;
      // 1) Se já temos um PreXMLPath salvo, usa ele
      if (PreXMLPath <> '') and FileExists(PreXMLPath) then
      begin
        Resp.AddPair('pre_xml_b64', FileToBase64(PreXMLPath));
        Exit;
      end;
      // 2) Tenta salvar no caminho padrão
      try
        PreXMLPath := ExtractFilePath(Application.ExeName) + 'logs\\requests\\pre_envio_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
        try ForceDirectories(ExtractFilePath(PreXMLPath)); except end;
        ACBrNFe1.NotasFiscais.Items[0].GravarXML(PreXMLPath);
        if FileExists(PreXMLPath) then
        begin
          Resp.AddPair('pre_xml_b64', FileToBase64(PreXMLPath));
          Exit;
        end;
      except
      end;
      // 3) Tenta salvar no diretório temporário do SO
      try
        TempPath := TPath.GetTempPath;
        Tmp := IncludeTrailingPathDelimiter(TempPath) + 'pre_envio_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
        ACBrNFe1.NotasFiscais.Items[0].GravarXML(Tmp);
        if FileExists(Tmp) then
        begin
          Resp.AddPair('pre_xml_b64', FileToBase64(Tmp));
          try DeleteFile(PChar(Tmp)); except end;
          Exit;
        end;
      except
      end;
    except
      on E: Exception do
      begin
        try Resp.AddPair('pre_xml_error', E.Message); except end;
      end;
    end;
  end;
begin
  Resp := TJSONObject.Create;
  try
    try
      BuildPhase := 'start';
      J := TJSONObject(TJSONObject.ParseJSONValue(JSONData));
      if not Assigned(J) then
        raise Exception.Create('JSON inválido');

      // Certificado (opcional)
      Conf := JsonGetObj(J, 'cert');
      if Assigned(Conf) then
      begin
        // Se vier número de série, priorizar uso do certificado instalado
        if JsonGetStr(Conf, 'serial', '') <> '' then
        begin
          ACBrNFe1.Configuracoes.Certificados.NumeroSerie := JsonGetStr(Conf, 'serial', '');
          // Limpar PFX para evitar conflito
          ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := '';
          ACBrNFe1.Configuracoes.Certificados.Senha := '';
        end
        else
        begin
          // Fallback: arquivo PFX + senha
          ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := JsonGetStr(Conf, 'path');
          ACBrNFe1.Configuracoes.Certificados.Senha := JsonGetStr(Conf, 'password');
          if (ACBrNFe1.Configuracoes.Certificados.ArquivoPFX = '') or
             (not FileExists(ACBrNFe1.Configuracoes.Certificados.ArquivoPFX)) then
            raise Exception.Create('Certificado PFX não encontrado: ' + ACBrNFe1.Configuracoes.Certificados.ArquivoPFX);

          // Carregamento ocorrerá automaticamente durante a assinatura/envio
        end;
      end;

      // Configurações
      Conf := JsonGetObj(J, 'configuracoes');
      if Assigned(Conf) then
      begin
        ACBrNFe1.Configuracoes.WebServices.UF := JsonGetStr(Conf, 'uf', 'SP');
        // Ambiente: deixar padrão configurado no ACBr para evitar dependência de constantes
        XMLPath := JsonGetStr(Conf, 'path_xml', '');
        if XMLPath <> '' then
          ACBrNFe1.Configuracoes.Arquivos.PathNFe := IncludeTrailingPathDelimiter(XMLPath);
        XMLPath := JsonGetStr(Conf, 'path_schemas', '');
        if XMLPath <> '' then
          ACBrNFe1.Configuracoes.Arquivos.PathSchemas := IncludeTrailingPathDelimiter(XMLPath);
      end;

      BuildPhase := 'building';
      ACBrNFe1.NotasFiscais.Clear;
      with ACBrNFe1.NotasFiscais.Add.NFe do
      begin
        // IDE
        Ide.modelo := 55;
        Ide.serie := JsonGetInt(J, 'serie', 1);
        // Se não vier numero_nfe no JSON, derive de numero_pedido removendo não dígitos
        var nNF := JsonGetInt(J, 'numero_nfe', 0);
        if (nNF <= 0) then
        begin
          var np := DigitsOnly(JsonGetStr(J, 'numero_pedido',''));
          if (np <> '') then
          begin
            var startIdx := Length(np) - 8;
            if startIdx < 1 then startIdx := 1;
            nNF := StrToIntDef(Copy(np, startIdx, 9), 0);
          end;
          if (nNF <= 0) then nNF := 1;
        end;
        Ide.nNF := nNF;
        // Ide.tpNF, Ide.tpEmis e Ide.procEmi mantidos padrão para ampla compatibilidade
        Ide.natOp := JsonGetStr(J, 'natOp', 'Venda de mercadoria');
        Ide.verProc := 'QFiscal-Delphi-1.0';
        // NFe 4.00: indicadores obrigatórios
        // Nesta build, evitar setar indFinal/indPres por enums para não quebrar a compilação;
        // deixar valores padrão do componente ACBr.

        // Emitente
        EmitObj := JsonGetObj(J, 'emitente');
        if Assigned(EmitObj) then
        begin
          Emit.CNPJCPF := DigitsOnly(JsonGetStr(EmitObj, 'cnpj',''));
          Emit.IE := DigitsOnly(JsonGetStr(EmitObj, 'ie',''));
          Emit.xNome := JsonGetStr(EmitObj, 'razao_social','');
          Emit.xFant := JsonGetStr(EmitObj, 'nome_fantasia','');
          Emit.EnderEmit.xLgr := JsonGetStr(EmitObj, 'endereco','');
          Emit.EnderEmit.nro := JsonGetStr(EmitObj, 'numero','');
          Emit.EnderEmit.xCpl := JsonGetStr(EmitObj, 'complemento','');
          Emit.EnderEmit.xBairro := JsonGetStr(EmitObj, 'bairro','');
          Emit.EnderEmit.cMun := StrToIntDef(JsonGetStr(EmitObj, 'codigo_ibge','0'), 0);
          if Emit.EnderEmit.cMun = 0 then
            Emit.EnderEmit.cMun := StrToIntDef(JsonGetStr(EmitObj, 'codigo_municipio','0'), 0);
          Emit.EnderEmit.xMun := JsonGetStr(EmitObj, 'cidade','');
          Emit.EnderEmit.UF := JsonGetStr(EmitObj, 'uf','SP');
          Emit.EnderEmit.CEP := StrToIntDef(DigitsOnly(JsonGetStr(EmitObj, 'cep','0')), 0);
          // CRT: manter padrão configurado no ACBr (não força enums para compatibilidade)
        end;

        // Destinatário
        DestObj := JsonGetObj(J, 'cliente');
        if Assigned(DestObj) then
        begin
          Dest.CNPJCPF := DigitsOnly(JsonGetStr(DestObj, 'cpf_cnpj',''));
          Dest.xNome := JsonGetStr(DestObj, 'nome','');
          Dest.IE := JsonGetStr(DestObj, 'ie','');
          if Dest.IE = '' then
            Dest.indIEDest := inNaoContribuinte
          else
            Dest.indIEDest := inContribuinte;
          Dest.EnderDest.xLgr := JsonGetStr(DestObj, 'endereco','');
          Dest.EnderDest.nro := JsonGetStr(DestObj, 'numero','');
          Dest.EnderDest.xBairro := JsonGetStr(DestObj, 'bairro','');
          Dest.EnderDest.cMun := StrToIntDef(JsonGetStr(DestObj, 'codigo_ibge','0'), 0);
          if Dest.EnderDest.cMun = 0 then
            Dest.EnderDest.cMun := StrToIntDef(JsonGetStr(DestObj, 'codigo_municipio','0'), 0);
          Dest.EnderDest.xMun := JsonGetStr(DestObj, 'cidade','');
          Dest.EnderDest.UF := JsonGetStr(DestObj, 'uf','');
          Dest.EnderDest.CEP := StrToIntDef(DigitsOnly(JsonGetStr(DestObj, 'cep','0')), 0);
        end;

        // Itens
        Itens := JsonGetArr(J, 'produtos');
        if Assigned(Itens) then
        begin
          for i := 0 to Itens.Count - 1 do
          begin
            ItemObj := Itens.Items[i] as TJSONObject;
            with Det.New do
            begin
              Prod.nItem := i+1;
              Prod.cProd := JsonGetStr(ItemObj, 'codigo', '');
              Prod.xProd := JsonGetStr(ItemObj, 'nome', '');
              Prod.NCM := JsonGetStr(ItemObj, 'ncm', '');
              Prod.CFOP := JsonGetStr(ItemObj, 'cfop', '5102');
              Prod.uCom := JsonGetStr(ItemObj, 'unidade', 'UN');
              Prod.qCom := StrToFloatDef(JsonGetStr(ItemObj, 'quantidade', '1'), 1.0);
              Prod.vUnCom := StrToFloatDef(JsonGetStr(ItemObj, 'valor_unitario', '0'), 0.0);
              Prod.vProd := StrToFloatDef(JsonGetStr(ItemObj, 'valor_total', ''), Prod.qCom * Prod.vUnCom);
              Prod.cEAN := JsonGetStr(ItemObj, 'ean', 'SEM GTIN');
              Prod.cEANTrib := Prod.cEAN;
              Prod.uTrib := Prod.uCom;
              Prod.qTrib := Prod.qCom;
              Prod.vUnTrib := Prod.vUnCom;
              // Impostos ICMS: deixar ACBr determinar/grupo conforme configuração do emissor
              // IndTot: remover para compatibilidade ampla em versões antigas do ACBr

              // ===== Mapear impostos no ACBr a partir dos valores do JSON =====
              try
              begin
                var BaseICMS    : Double := StrToFloatDef(JsonGetStr(ItemObj, 'base_icms', '0'), 0);
                var AliqICMS    : Double := StrToFloatDef(JsonGetStr(ItemObj, 'aliquota_icms', '0'), 0);
                var ValorICMS   : Double := StrToFloatDef(JsonGetStr(ItemObj, 'valor_icms', '0'), 0);
                // var CSTICMS  : string := JsonGetStr(ItemObj, 'cst_icms', '00');
                // var OrigemStr: string := JsonGetStr(ItemObj, 'origem', '0');

                var AliqPIS     : Double := StrToFloatDef(JsonGetStr(ItemObj, 'aliquota_pis', '0'), 0);
                var ValorPIS    : Double := StrToFloatDef(JsonGetStr(ItemObj, 'valor_pis', '0'), 0);
                // var CSTPIS   : string := JsonGetStr(ItemObj, 'cst_pis', '01');

                var AliqCOFINS  : Double := StrToFloatDef(JsonGetStr(ItemObj, 'aliquota_cofins', '0'), 0);
                var ValorCOFINS : Double := StrToFloatDef(JsonGetStr(ItemObj, 'valor_cofins', '0'), 0);
                // var CSTCOFINS: string := JsonGetStr(ItemObj, 'cst_cofins', '01');

                // ICMS (grupo básico) - preencher CST e origem com defaults seguros
                try
                begin
                  var cstIcmsStr := JsonGetStr(ItemObj, 'cst_icms', '00');
                  if cstIcmsStr = '00' then Imposto.ICMS.CST := cst00
                  else if cstIcmsStr = '10' then Imposto.ICMS.CST := cst10
                  else if cstIcmsStr = '20' then Imposto.ICMS.CST := cst20
                  else if cstIcmsStr = '30' then Imposto.ICMS.CST := cst30
                  else if cstIcmsStr = '40' then Imposto.ICMS.CST := cst40
                  else if cstIcmsStr = '41' then Imposto.ICMS.CST := cst41
                  else if cstIcmsStr = '50' then Imposto.ICMS.CST := cst50
                  else if cstIcmsStr = '51' then Imposto.ICMS.CST := cst51
                  else if cstIcmsStr = '60' then Imposto.ICMS.CST := cst60
                  else if cstIcmsStr = '70' then Imposto.ICMS.CST := cst70
                  else if cstIcmsStr = '90' then Imposto.ICMS.CST := cst90
                  else Imposto.ICMS.CST := cst00;
                end; except end;
                // Origem: usa default seguro para evitar dependência de enums ausentes na build
                try Imposto.ICMS.orig := oeNacional; except end;

                // Campos numéricos
                Imposto.ICMS.vBC   := BaseICMS;
                Imposto.ICMS.pICMS := AliqICMS;
                Imposto.ICMS.vICMS := ValorICMS;

                // PIS (alíquota)
                try
                begin
                  var cstPisStr := JsonGetStr(ItemObj, 'cst_pis', '01');
                  if cstPisStr = '49' then Imposto.PIS.CST := pis49
                  else if cstPisStr = '01' then Imposto.PIS.CST := pis01
                  else if cstPisStr = '02' then Imposto.PIS.CST := pis02
                  else Imposto.PIS.CST := pis01;
                end; except end;
                Imposto.PIS.vBC  := BaseICMS;
                Imposto.PIS.pPIS := AliqPIS;
                Imposto.PIS.vPIS := ValorPIS;

                // COFINS (alíquota)
                try
                begin
                  var cstCofStr := JsonGetStr(ItemObj, 'cst_cofins', '01');
                  if cstCofStr = '49' then Imposto.COFINS.CST := cof49
                  else if cstCofStr = '01' then Imposto.COFINS.CST := cof01
                  else if cstCofStr = '02' then Imposto.COFINS.CST := cof02
                  else Imposto.COFINS.CST := cof01;
                end; except end;
                Imposto.COFINS.vBC     := BaseICMS;
                Imposto.COFINS.pCOFINS := AliqCOFINS;
                Imposto.COFINS.vCOFINS := ValorCOFINS;
              end;
              except
                // Se algo falhar no mapeamento, deixa ACBr calcular/validar conforme configuração
              end;
            end;
          end;
        end;

        // Transporte (somente quando necessário)
        begin
          var TranspObj := JsonGetObj(J, 'transporte');
          if Assigned(TranspObj) then
          begin
            var fm := StrToIntDef(JsonGetStr(TranspObj, 'modalidade', '9'), 9);
            // Deixa modFrete conforme configuração padrão do ACBr para evitar dependência de enum na build
            var VolObj := JsonGetObj(TranspObj, 'volumes');
            var explicit := Assigned(VolObj);
            if (fm <> 9) or explicit then
            begin
              with Transp.Vol.New do
              begin
                qVol := StrToIntDef(JsonGetStr(VolObj, 'quantidade', '1'), 1);
                if qVol < 1 then qVol := 1;
                esp := JsonGetStr(VolObj, 'especie', 'VOL');
                pesoB := StrToFloatDef(JsonGetStr(VolObj, 'peso_bruto', '0.1'), 0.1);
                if pesoB <= 0 then pesoB := 0.1;
                pesoL := StrToFloatDef(JsonGetStr(VolObj, 'peso_liquido', '0.1'), 0.1);
                if pesoL <= 0 then pesoL := 0.1;
              end;
            end;
          end;
        end;

        // Pagamentos (NFe 4.00)
        begin
          var Pays := JsonGetArr(J, 'pagamentos');
          if Assigned(Pays) then
          begin
            var pj: Integer;
            for pj := 0 to Pays.Count - 1 do
            begin
              var PayObj := Pays.Items[pj] as TJSONObject;
              try
                with pag.New do
                begin
                  // Algumas versões do ACBr não expõem detPag/tPag; ao menos informe vPag
                  vPag := StrToFloatDef(JsonGetStr(PayObj, 'valor', '0'), 0.0);
                end;
              except
              end;
            end;
            // vTroco opcional
            try
            begin
              var vTrocoStr := JsonGetStr(J, 'vTroco', '');
              if vTrocoStr <> '' then
                try pag.vTroco := StrToFloatDef(vTrocoStr, 0.0); except end;
            end; except end;
          end;
        end;
      end; // with NFe
      BuildPhase := 'built';

      // Totais (se enviados no JSON) para evitar falhas de nós nulos
      try
        var TotObj := JsonGetObj(J, 'totais');
        if Assigned(TotObj) and (ACBrNFe1.NotasFiscais.Count > 0) then
        begin
          with ACBrNFe1.NotasFiscais.Items[0].NFe.Total do
          begin
            // ICMSTot completo quando disponível
            var IcmsTotObj := JsonGetObj(TotObj, 'ICMSTot');
            if Assigned(IcmsTotObj) then
            begin
              ICMSTot.vBC        := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vBC', '0'), 0);
              ICMSTot.vICMS      := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vICMS', '0'), 0);
              ICMSTot.vICMSDeson := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vICMSDeson', '0'), 0);
              ICMSTot.vFCP       := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vFCP', '0'), 0);
              ICMSTot.vBCST      := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vBCST', '0'), 0);
              ICMSTot.vST        := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vST', '0'), 0);
              ICMSTot.vFCPST     := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vFCPST', '0'), 0);
              ICMSTot.vFCPSTRet  := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vFCPSTRet', '0'), 0);
              ICMSTot.vProd      := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vProd', '0'), 0);
              ICMSTot.vFrete     := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vFrete', '0'), 0);
              ICMSTot.vSeg       := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vSeg', '0'), 0);
              ICMSTot.vDesc      := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vDesc', '0'), 0);
              ICMSTot.vII        := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vII', '0'), 0);
              ICMSTot.vIPI       := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vIPI', '0'), 0);
              ICMSTot.vIPIDevol  := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vIPIDevol', '0'), 0);
              ICMSTot.vPIS       := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vPIS', '0'), 0);
              ICMSTot.vCOFINS    := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vCOFINS', '0'), 0);
              ICMSTot.vOutro     := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vOutro', '0'), 0);
              ICMSTot.vNF        := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vNF', '0'), 0);
            end
            else
            begin
              // Fallback com campos de Totais no nível superior
              ICMSTot.vProd  := StrToFloatDef(JsonGetStr(TotObj, 'vProd', '0'), 0);
              ICMSTot.vDesc  := StrToFloatDef(JsonGetStr(TotObj, 'vDesc', '0'), 0);
              ICMSTot.vFrete := StrToFloatDef(JsonGetStr(TotObj, 'vFrete', '0'), 0);
              ICMSTot.vSeg   := StrToFloatDef(JsonGetStr(TotObj, 'vSeg', '0'), 0);
              ICMSTot.vOutro := StrToFloatDef(JsonGetStr(TotObj, 'vOutro', '0'), 0);
              ICMSTot.vNF    := StrToFloatDef(JsonGetStr(TotObj, 'vNF', '0'), 0);
            end;
          end;
        end;
      except
      end;

      // Dump do XML de pré-envio para diagnóstico
      try
        BuildPhase := 'pre_save_xml';
        PreXMLPath := ExtractFilePath(Application.ExeName) + 'logs\\requests\\pre_envio_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
        // Garante diretório
        try ForceDirectories(ExtractFilePath(PreXMLPath)); except end;
        if ACBrNFe1.NotasFiscais.Count > 0 then
        begin
          ACBrNFe1.NotasFiscais.Items[0].GravarXML(PreXMLPath);
          // Grava também uma cópia em C:\temp para facilitar inspeção
          try
            var AltDir := 'C:\\temp\\';
            var AltPath := AltDir + 'pre_envio_latest.xml';
            if not DirectoryExists(AltDir) then ForceDirectories(AltDir);
            ACBrNFe1.NotasFiscais.Items[0].GravarXML(AltPath);
            try TFile.Copy(PreXMLPath, AltPath, True); except end;
            Resp.AddPair('pre_xml_path_alt', AltPath);
          except
          end;
        end;
        // Tenta anexar em base64 de qualquer maneira
        AttachPreXMLBase64;
      except
        BuildPhase := 'pre_save_xml_error';
        PreXMLPath := '';
        // Retorna XML inline em base64
        AttachPreXMLBase64;
      end;

      // Garantia: se o XML não contiver o grupo <pag>, injeta a partir do JSON e recarrega
      try
        var PaysJson := JsonGetArr(J, 'pagamentos');
        if (PreXMLPath <> '') and FileExists(PreXMLPath) and Assigned(PaysJson) and (PaysJson.Count > 0) then
        begin
          var PayFirst := PaysJson.Items[0] as TJSONObject;
          var tPagStr := JsonGetStr(PayFirst, 'tPag', '01');
          var vPagVal := StrToFloatDef(JsonGetStr(PayFirst, 'valor', '0'), 0.0);
          var XMLText := TFile.ReadAllText(PreXMLPath, TEncoding.UTF8);
          if (Pos('<pag>', XMLText) = 0) and (Pos('<detPag>', XMLText) = 0) then
          begin
            var FS := TFormatSettings.Create;
            FS.DecimalSeparator := '.';
            var vPagStr := FormatFloat('0.00', vPagVal, FS);
            var Inject := '<pag><detPag><tPag>' + tPagStr + '</tPag><vPag>' + vPagStr + '</vPag></detPag></pag>';
            // Insere antes do fechamento de </infNFe>
            XMLText := StringReplace(XMLText, '</infNFe>', Inject + '</infNFe>', []);
            TFile.WriteAllText(PreXMLPath, XMLText, TEncoding.UTF8);
            // Copia também para C:\temp\pre_envio_latest.xml
            try
              var AltDir2 := 'C:\\temp\\';
              var AltPath2 := AltDir2 + 'pre_envio_latest.xml';
              if not DirectoryExists(AltDir2) then ForceDirectories(AltDir2);
              TFile.Copy(PreXMLPath, AltPath2, True);
            except
            end;
            // Recarrega no ACBr para envio
            ACBrNFe1.NotasFiscais.Clear;
            ACBrNFe1.NotasFiscais.LoadFromFile(PreXMLPath);
          end;
        end;
      except
      end;

      // Assinar, validar e enviar
      try
        BuildPhase := 'enviar';
        if not ACBrNFe1.Enviar(1) then
          raise Exception.Create('Falha ao transmitir NFe');
      except
        on E: Exception do
        begin
          // Salva XML gerado (mesmo com falha) para diagnóstico
          try
            DebugXML := ExtractFilePath(Application.ExeName) + 'logs\\requests\\ultimanfe_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
            try ForceDirectories(ExtractFilePath(DebugXML)); except end;
            if ACBrNFe1.NotasFiscais.Count > 0 then
              ACBrNFe1.NotasFiscais.Items[0].GravarXML(DebugXML);
          except
          end;
          // Também retorna inline em base64
          try
            if DebugXML <> '' then
              Resp.AddPair('ultimanfe_b64', FileToBase64(DebugXML));
          except end;
          BuildPhase := 'enviar_error';
          raise;
        end;
      end;

      // Resultado
      Chave := ACBrNFe1.NotasFiscais.Items[0].NFe.infNFe.ID;
      Protocolo := ACBrNFe1.WebServices.Retorno.Protocolo;
      XMLPath := ACBrNFe1.NotasFiscais.Items[0].NomeArq;
      // Status/motivo da SEFAZ
      var RetCStat: Integer := 0;
      var RetXMotivo: string := '';
      try
        RetCStat := ACBrNFe1.WebServices.Retorno.cStat;
        RetXMotivo := ACBrNFe1.WebServices.Retorno.xMotivo;
      except end;
      try
        ACBrNFe1.NotasFiscais.Imprimir;
        PDFPath := ChangeFileExt(XMLPath, '.pdf');
      except
        PDFPath := '';
      end;

      Resp.AddPair('ok', TJSONBool.Create(True));
      Resp.AddPair('chave', Chave);
      Resp.AddPair('protocolo', Protocolo);
      Resp.AddPair('xml_path', XMLPath);
      Resp.AddPair('cStat', TJSONNumber.Create(RetCStat));
      if RetXMotivo <> '' then Resp.AddPair('xMotivo', RetXMotivo);
      if PDFPath <> '' then Resp.AddPair('pdf_path', PDFPath);
      if PreXMLPath <> '' then Resp.AddPair('pre_xml_path', PreXMLPath);
      Resp.AddPair('build_phase', BuildPhase);
      // Garantia extra: se ainda não anexou, tenta no final
      AttachPreXMLBase64;
    except
      on E: Exception do
      begin
        Resp.AddPair('ok', TJSONBool.Create(False));
        Resp.AddPair('error', E.Message);
        if PreXMLPath <> '' then Resp.AddPair('pre_xml_path', PreXMLPath);
        if BuildPhase <> '' then Resp.AddPair('build_phase', BuildPhase);
        // Tenta salvar XML mesmo em erro de montagem
        try
          var ErrXML := ExtractFilePath(Application.ExeName) + 'logs\\requests\\build_error_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
          if ACBrNFe1.NotasFiscais.Count > 0 then
          begin
            ACBrNFe1.NotasFiscais.Items[0].GravarXML(ErrXML);
            Resp.AddPair('build_xml_path', ErrXML);
            // E inline em base64
            try Resp.AddPair('build_xml_b64', FileToBase64(ErrXML)); except end;
          end;
        except end;
        // Adiciona detalhes de rejeição quando disponíveis
        try
          var RetCStat2 := ACBrNFe1.WebServices.Retorno.cStat;
          var RetXMotivo2 := ACBrNFe1.WebServices.Retorno.xMotivo;
          Resp.AddPair('cStat', TJSONNumber.Create(RetCStat2));
          if RetXMotivo2 <> '' then Resp.AddPair('xMotivo', RetXMotivo2);
          // Salva XML de retorno do webservice
          var RetWS := '';
          try RetWS := ACBrNFe1.WebServices.Retorno.RetWS; except end;
          if RetWS <> '' then
          begin
            var LogDir := ExtractFilePath(Application.ExeName) + 'logs\';
            if not DirectoryExists(LogDir) then ForceDirectories(LogDir);
            var RetPath := LogDir + 'retorno_ws_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
            try
              var F: TextFile;
              AssignFile(F, RetPath);
              Rewrite(F);
              try Writeln(F, RetWS); finally CloseFile(F); end;
              Resp.AddPair('ret_ws_path', RetPath);
            except end;
          end;
        except end;
      end;
    end;
    Result := Resp.ToString;
  finally
    Resp.Free;
  end;
end;

function TForm1.CancelarNFeJSON(const JSONData: string): string;
var
  J: TJSONObject;
  Resp: TJSONObject;
  xmlPath, chave, justificativa, emitCNPJ, xmlRet: string;
begin
  Resp := TJSONObject.Create;
  try
    try
      J := TJSONObject(TJSONObject.ParseJSONValue(JSONData));
      if not Assigned(J) then
        raise Exception.Create('JSON inválido');

      xmlPath := JsonGetStr(J, 'xml_path', '');
      chave := JsonGetStr(J, 'chave', '');
      justificativa := JsonGetStr(J, 'justificativa', '');
      emitCNPJ := JsonGetStr(J, 'emit_cnpj', '');
      if Length(justificativa) < 15 then
        raise Exception.Create('Justificativa deve ter no mínimo 15 caracteres');

      ACBrNFe1.NotasFiscais.Clear;
      if xmlPath <> '' then
        ACBrNFe1.NotasFiscais.LoadFromFile(xmlPath);

      ACBrNFe1.EventoNFe.Evento.Clear;
      ACBrNFe1.EventoNFe.idLote := 1;
      with ACBrNFe1.EventoNFe.Evento.New do
      begin
        infEvento.dhEvento := Now;
        // Tipo Cancelamento (teCancelamento)
        infEvento.tpEvento := teCancelamento;
        if chave <> '' then
          infEvento.chNFe := chave;
        if emitCNPJ <> '' then
          infEvento.CNPJ := emitCNPJ;
        infEvento.detEvento.xJust := justificativa;
      end;

      ACBrNFe1.EnviarEvento(1);
      xmlRet := ACBrNFe1.WebServices.EnvEvento.EventoRetorno.XmlRetorno;

      Resp.AddPair('ok', TJSONBool.Create(True));
      if xmlPath <> '' then Resp.AddPair('xml_referencia', xmlPath);
      if chave <> '' then Resp.AddPair('chave', chave);
      Resp.AddPair('xml_retorno', xmlRet);
    except
      on E: Exception do
      begin
        Resp.AddPair('ok', TJSONBool.Create(False));
        Resp.AddPair('error', E.Message);
      end;
    end;
    Result := Resp.ToString;
  finally
    Resp.Free;
  end;
end;

function TForm1.CartaCorrecaoJSON(const JSONData: string): string;
var
  J: TJSONObject;
  Resp: TJSONObject;
  xmlPath, chave, correcao, emitCNPJ, xmlRet: string;
  seq: Integer;
begin
  Resp := TJSONObject.Create;
  try
    try
      J := TJSONObject(TJSONObject.ParseJSONValue(JSONData));
      if not Assigned(J) then
        raise Exception.Create('JSON inválido');

      xmlPath := JsonGetStr(J, 'xml_path', '');
      chave := JsonGetStr(J, 'chave', '');
      correcao := JsonGetStr(J, 'correcao', '');
      emitCNPJ := JsonGetStr(J, 'emit_cnpj', '');
      seq := JsonGetInt(J, 'sequencia', 1);
      if Length(correcao) < 15 then
        raise Exception.Create('Texto da correção deve ter no mínimo 15 caracteres');

      ACBrNFe1.NotasFiscais.Clear;
      if xmlPath <> '' then
        ACBrNFe1.NotasFiscais.LoadFromFile(xmlPath);

      ACBrNFe1.EventoNFe.Evento.Clear;
      ACBrNFe1.EventoNFe.idLote := 1;
      with ACBrNFe1.EventoNFe.Evento.New do
      begin
        infEvento.dhEvento := Now;
        // Tipo Carta de Correção (teCCe)
        infEvento.tpEvento := teCCe;
        if chave <> '' then
          infEvento.chNFe := chave;
        if emitCNPJ <> '' then
          infEvento.CNPJ := emitCNPJ;
        infEvento.nSeqEvento := seq;
        infEvento.detEvento.xCorrecao := correcao;
      end;

      ACBrNFe1.EnviarEvento(1);
      xmlRet := ACBrNFe1.WebServices.EnvEvento.EventoRetorno.XmlRetorno;

      Resp.AddPair('ok', TJSONBool.Create(True));
      if xmlPath <> '' then Resp.AddPair('xml_referencia', xmlPath);
      if chave <> '' then Resp.AddPair('chave', chave);
      Resp.AddPair('xml_retorno', xmlRet);
    except
      on E: Exception do
      begin
        Resp.AddPair('ok', TJSONBool.Create(False));
        Resp.AddPair('error', E.Message);
      end;
    end;
    Result := Resp.ToString;
  finally
    Resp.Free;
  end;
end;

function TForm1.JsonGetObj(Obj: TJSONObject; const Key: string): TJSONObject;
var V: TJSONValue;
begin
  Result := nil;
  if not Assigned(Obj) then Exit;
  V := Obj.Values[Key];
  if (V <> nil) and (V is TJSONObject) then
    Result := TJSONObject(V);
end;

function TForm1.JsonGetArr(Obj: TJSONObject; const Key: string): TJSONArray;
var V: TJSONValue;
begin
  Result := nil;
  if not Assigned(Obj) then Exit;
  V := Obj.Values[Key];
  if (V <> nil) and (V is TJSONArray) then
    Result := TJSONArray(V);
end;

function TForm1.JsonGetStr(Obj: TJSONObject; const Key: string; const Default: string): string;
var V: TJSONValue;
begin
  Result := Default;
  if not Assigned(Obj) then Exit;
  V := Obj.Values[Key];
  if (V <> nil) then
    Result := V.Value;
end;

function TForm1.JsonGetInt(Obj: TJSONObject; const Key: string; const Default: Integer): Integer;
var s: string;
begin
  s := JsonGetStr(Obj, Key, IntToStr(Default));
  Result := StrToIntDef(s, Default);
end;

// ===== FUNÇÕES DE SEGURANÇA =====

function TForm1.ValidateToken(ARequestInfo: TIdHTTPRequestInfo): Boolean;
var
  Token: string;
begin
  Result := False;
  
  // Se não há tokens configurados, permite acesso (modo desenvolvimento)
  if FValidTokens.Count = 0 then
  begin
    Result := True;
    Exit;
  end;
  
  Token := ExtractTokenFromHeader(ARequestInfo);
  if Token = '' then Exit;
  
  // Verifica se o token está na lista de tokens válidos
  Result := FValidTokens.IndexOf(Token) >= 0;
end;

function TForm1.ExtractTokenFromHeader(ARequestInfo: TIdHTTPRequestInfo): string;
var
  AuthHeader, XToken: string;
begin
  Result := '';
  // 1) Authorization: Bearer <token>
  AuthHeader := ARequestInfo.RawHeaders.Values['Authorization'];
  if (AuthHeader <> '') and (Pos('Bearer ', AuthHeader) = 1) then
  begin
    Result := Copy(AuthHeader, 8, Length(AuthHeader) - 7);
    Exit;
  end;
  // 2) X-Token: <token>
  XToken := ARequestInfo.RawHeaders.Values['X-Token'];
  if (XToken <> '') then
  begin
    Result := XToken;
    Exit;
  end;
  // 3) ?token=<token>
  if (ARequestInfo.Params.Values['token'] <> '') then
  begin
    Result := ARequestInfo.Params.Values['token'];
    Exit;
  end;
end;

procedure TForm1.LogSecurityEvent(const EventType, Details: string);
var
  LogFile: TextFile;
  LogPath: string;
  DateTimeStr: string;
begin
  try
    // Cria diretório de logs se não existir
    LogPath := ExtractFilePath(Application.ExeName) + 'logs\';
    if not DirectoryExists(LogPath) then
      ForceDirectories(LogPath);
    
    // Nome do arquivo de log com data
    LogPath := LogPath + 'security_' + FormatDateTime('yyyy-mm-dd', Now) + '.log';
    
    // Formata data/hora
    DateTimeStr := FormatDateTime('yyyy-mm-dd hh:nn:ss', Now);
    
    // Escreve no arquivo de log
    AssignFile(LogFile, LogPath);
    if FileExists(LogPath) then
      Append(LogFile)
    else
      Rewrite(LogFile);
    
    try
      Writeln(LogFile, '[' + DateTimeStr + '] ' + EventType + ': ' + Details);
    finally
      CloseFile(LogFile);
    end;
  except
    // Em caso de erro, não interrompe o funcionamento
  end;
end;

procedure TForm1.LoadValidTokens;
var
  ConfigFile: TextFile;
  ConfigPath: string;
  Line: string;
begin
  FValidTokens.Clear;
  
  try
    // Arquivo de configuração de tokens
    ConfigPath := ExtractFilePath(Application.ExeName) + 'tokens.txt';
    
    if FileExists(ConfigPath) then
    begin
      AssignFile(ConfigFile, ConfigPath);
      Reset(ConfigFile);
      
      try
        while not Eof(ConfigFile) do
        begin
          Readln(ConfigFile, Line);
          Line := Trim(Line);
          
          // Ignora linhas vazias e comentários
          if (Line <> '') and (Pos('#', Line) <> 1) then
          begin
            FValidTokens.Add(Line);
          end;
        end;
      finally
        CloseFile(ConfigFile);
      end;
    end
    else
    begin
      // Cria arquivo de exemplo se não existir
      AssignFile(ConfigFile, ConfigPath);
      Rewrite(ConfigFile);
      try
        Writeln(ConfigFile, '# Arquivo de tokens válidos para o emissor');
        Writeln(ConfigFile, '# Um token por linha');
        Writeln(ConfigFile, '# Linhas iniciadas com # são comentários');
        Writeln(ConfigFile, '');
        Writeln(ConfigFile, '# Token padrão (altere este valor)');
        Writeln(ConfigFile, 'qfiscal_default_token_2025');
      finally
        CloseFile(ConfigFile);
      end;
      
      // Adiciona token padrão
      FValidTokens.Add('qfiscal_default_token_2025');
    end;
  except
    // Em caso de erro, adiciona token padrão
    FValidTokens.Add('qfiscal_default_token_2025');
  end;
end;

end.
