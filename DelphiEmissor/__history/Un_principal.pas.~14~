unit Un_principal;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, ACBrValidador, ACBrDFeReport,
  ACBrDFeDANFeReport, ACBrNFeDANFEClass, ACBrNFeDANFeRLClass, ACBrBase, ACBrDFe,
  ACBrNFe, ACBrDFeSSL, System.NetEncoding, System.IOUtils, IdURI,
  // Indy HTTP
  IdHTTPServer, IdContext, IdCustomHTTPServer,
  // JSON
  System.JSON, ACBrNFSe, pcnConversao, ActiveX,
  TypInfo,
  ACBrNFeDANFeFPDF, System.Generics.Collections;

type
  TForm1 = class(TForm)
  published
    ACBrNFe1: TACBrNFe;
    ACBrNFeDANFeRL1: TACBrNFeDANFeRL;
    ACBrValidador1: TACBrValidador;
    ACBrNFSe1: TACBrNFSe;
    procedure FormCreate(Sender: TObject);
    procedure IdHTTPServer1CommandGet(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo;
      AResponseInfo: TIdHTTPResponseInfo);
  private
    FServer: TIdHTTPServer;
    FValidTokens: TStringList;
    function ReadRequestBody(ARequestInfo: TIdHTTPRequestInfo): string;
    function EmitirNFeJSON(const JSONData: string): string;
    function GerarDanfeJSON(const JSONData: string): string;
    function CancelarNFeJSON(const JSONData: string): string;
    function CartaCorrecaoJSON(const JSONData: string): string;
    function InutilizarNFeJSON(const JSONData: string): string;
    function EmitirNFSeJSON(const JSONData: string): string;
    function JsonGetObj(Obj: TJSONObject; const Key: string): TJSONObject;
    function JsonGetArr(Obj: TJSONObject; const Key: string): TJSONArray;
    function JsonGetStr(Obj: TJSONObject; const Key: string; const Default: string = ''): string;
    function JsonGetInt(Obj: TJSONObject; const Key: string; const Default: Integer = 0): Integer;
    function ValidateToken(ARequestInfo: TIdHTTPRequestInfo): Boolean;
    function ExtractTokenFromHeader(ARequestInfo: TIdHTTPRequestInfo): string;
    procedure LogSecurityEvent(const EventType, Details: string);
    procedure LoadValidTokens;
  public
    { Public declarations }
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

function DigitsOnly(const S: string): string;
var i: Integer; ch: Char;
begin
  Result := '';
  for i := 1 to Length(S) do
  begin
    ch := S[i];
    if (ch >= '0') and (ch <= '9') then
      Result := Result + ch;
  end;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  // Inicializa COM para evitar erros WIC/Graphics ao gerar PDF/Imagens
  try CoInitialize(nil); except end;
  try
    Caption := 'Inicializando ACBr...';
    ACBrNFe1.Configuracoes.WebServices.Visualizar := False;
    ACBrNFe1.Configuracoes.WebServices.Salvar := True;
    ACBrNFe1.Configuracoes.Arquivos.Salvar := True;
    // Garante NFe 4.00 e validação de schema ativa
    // VersaoDF pode variar entre versões do ACBr; manter padrão do componente
    try ACBrNFe1.Configuracoes.Geral.ExibirErroSchema := True; except end;
    ACBrNFe1.DANFE := ACBrNFeDANFeRL1;

    Caption := 'Configurando SSL...';
    ACBrNFe1.Configuracoes.Geral.SSLLib := libOpenSSL;
    ACBrNFe1.Configuracoes.Geral.SSLCryptLib := cryOpenSSL;
    ACBrNFe1.Configuracoes.Geral.SSLHttpLib := httpOpenSSL;
    ACBrNFe1.Configuracoes.Geral.SSLXmlSignLib := xsLibXml2;

    // Configuração do DANFE (FortesReport) para ambiente com restrições WIC
    try
      ACBrNFeDANFeRL1.Logo := '';
    except end;

    // Diretório padrão para XMLs e logs ao lado do executável
    try
      ACBrNFe1.Configuracoes.Arquivos.PathNFe := IncludeTrailingPathDelimiter(ExtractFilePath(Application.ExeName) + 'nfe');
      if not DirectoryExists(ACBrNFe1.Configuracoes.Arquivos.PathNFe) then
        ForceDirectories(ACBrNFe1.Configuracoes.Arquivos.PathNFe);
      // PathSchemas opcional (se existir ao lado do exe)
      if DirectoryExists(ExtractFilePath(Application.ExeName) + 'Schemas') then
        ACBrNFe1.Configuracoes.Arquivos.PathSchemas := IncludeTrailingPathDelimiter(ExtractFilePath(Application.ExeName) + 'Schemas');
      if not DirectoryExists(ExtractFilePath(Application.ExeName) + 'logs') then
        ForceDirectories(ExtractFilePath(Application.ExeName) + 'logs');
      if not DirectoryExists(ExtractFilePath(Application.ExeName) + 'logs\\requests') then
        ForceDirectories(ExtractFilePath(Application.ExeName) + 'logs\\requests');
    except
      // ignora erros de IO aqui
    end;

    Caption := 'Inicializando tokens...';
    FValidTokens := TStringList.Create;
    LoadValidTokens;

    Caption := 'Iniciando servidor HTTP...';
    FServer := TIdHTTPServer.Create(Self);
    FServer.OnCommandGet := IdHTTPServer1CommandGet;
    FServer.OnCommandOther := IdHTTPServer1CommandGet; // garante tratamento de POST/OPTIONS/etc
    FServer.Bindings.Clear;
    with FServer.Bindings.Add do
    begin
      IP := '0.0.0.0';
      Port := 18080;
    end;
    FServer.Active := True;

    Caption := 'Emissor NFe/NFS-e - Porta 18080 - Seguro [' + FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ']';
    // Grava build_info para confirmar a versão em execução
    try
      var LogDir := ExtractFilePath(Application.ExeName) + 'logs\\';
      if not DirectoryExists(LogDir) then ForceDirectories(LogDir);
      var F: TextFile;
      AssignFile(F, LogDir + 'build_info.txt');
      Rewrite(F);
      try
        Writeln(F, 'started_at=' + FormatDateTime('yyyy-mm-dd hh:nn:ss', Now));
        Writeln(F, 'features=impostos_no_item;status_ext;payload_logs');
        Writeln(F, 'exe=' + Application.ExeName);
      finally
        CloseFile(F);
      end;
    except
    end;
    LogSecurityEvent('STARTUP', 'Emissor iniciado com sistema de segurança');
  except
    on E: Exception do
    begin
      ShowMessage('Erro no FormCreate: ' + E.Message + sLineBreak + 'Caption atual: ' + Caption);
      Caption := 'Emissor - erro';
    end;
  end;
end;



function TForm1.ReadRequestBody(ARequestInfo: TIdHTTPRequestInfo): string;
var
  ss: TStringStream;
begin
  Result := '';
  if Assigned(ARequestInfo.PostStream) then
  begin
    ss := TStringStream.Create('', TEncoding.UTF8);
    try
      ARequestInfo.PostStream.Position := 0;
      ss.CopyFrom(ARequestInfo.PostStream, ARequestInfo.PostStream.Size);
      Result := ss.DataString;
    finally
      ss.Free;
    end;
  end
  else
    Result := ARequestInfo.UnparsedParams;
end;

procedure TForm1.IdHTTPServer1CommandGet(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo;
  AResponseInfo: TIdHTTPResponseInfo);
var
  Path, Body, Resp: string;
begin
  // CORS básico
  AResponseInfo.CustomHeaders.Values['Access-Control-Allow-Origin'] := '*';
  AResponseInfo.CustomHeaders.Values['Access-Control-Allow-Methods'] := 'GET, POST, OPTIONS';
  AResponseInfo.CustomHeaders.Values['Access-Control-Allow-Headers'] := 'Content-Type, Authorization, X-Token, X-Authorization, X-Api-Token';
  // Força charset UTF-8 para evitar caracteres quebrados em acentuação
  AResponseInfo.CharSet := 'utf-8';

  if SameText(ARequestInfo.Command, 'OPTIONS') then
  begin
    AResponseInfo.ResponseNo := 200;
    Exit;
  end;

  try
    Path := LowerCase(ARequestInfo.Document);
    // Normalização do caminho: URL-decode, trim e remoção de barra final
    try
      Path := LowerCase(TIdURI.URLDecode(Path));
    except
    end;
    Path := Trim(Path);
    // Remove querystring, se houver
    var qpos := Pos('?', Path);
    if qpos > 0 then
      Path := Copy(Path, 1, qpos - 1);
    if (Length(Path) > 1) and (Path[Length(Path)] = '/') then
      Delete(Path, Length(Path), 1);

    // Log básico da requisição (método e caminho)
    try
      var LogDir := ExtractFilePath(Application.ExeName) + 'logs\';
      if not DirectoryExists(LogDir) then ForceDirectories(LogDir);
      var F: TextFile;
      AssignFile(F, LogDir + 'access_' + FormatDateTime('yyyymmdd', Now) + '.log');
      if FileExists(LogDir + 'access_' + FormatDateTime('yyyymmdd', Now) + '.log') then
        Append(F)
      else
        Rewrite(F);
      try
        Writeln(F, FormatDateTime('hh:nn:ss', Now) + ' ' + ARequestInfo.Command + ' ' + Path);
      finally
        CloseFile(F);
      end;
    except
    end;
    
    // Endpoint público (sem autenticação)
    if (ARequestInfo.Command = 'GET') and (Path = '/api/status') then
    begin
      AResponseInfo.ResponseNo := 200;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := '{"ok":true,"message":"Emissor ativo","cert_ok":true}';
      Exit;
    end;

    // Endpoints protegidos (requerem autenticação)
    if (Path = '/api/emitir-nfe') and (ARequestInfo.Command <> 'POST') then
    begin
      AResponseInfo.ResponseNo := 405;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := '{"ok":false,"error":"use POST em /api/emitir-nfe"}';
      Exit;
    end;

    // Geração apenas do DANFE a partir de XML autorizado
    if (ARequestInfo.Command = 'POST') and (Path = '/api/gerar-danfe') then
    begin
      if not ValidateToken(ARequestInfo) then
      begin
        AResponseInfo.ResponseNo := 401;
        AResponseInfo.ContentType := 'application/json';
        AResponseInfo.ContentText := '{"error":"Token de autenticação inválido ou ausente"}';
        LogSecurityEvent('AUTH_FAILED', 'Tentativa de gerar DANFE sem token válido - IP: ' + AContext.Binding.PeerIP);
        Exit;
      end;
      Body := ReadRequestBody(ARequestInfo);
      // Fallbacks: aceitar JSON via query (json/urlencode) ou xml_path direto
      if (Body = '') then
      begin
        try
          var QJson := ARequestInfo.Params.Values['json'];
          if QJson <> '' then
            Body := TIdURI.URLDecode(QJson);
        except end;
        if (Body = '') then
        begin
          var QXml := ARequestInfo.Params.Values['xml_path'];
          if QXml <> '' then
            Body := '{"xml_path":"' + StringReplace(QXml, '"', '\"', [rfReplaceAll]) + '","configuracoes":{"gerar_pdf":true}}';
        end;
      end;
      Resp := GerarDanfeJSON(Body);
      AResponseInfo.ResponseNo := 200;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := Resp;
      Exit;
    end;

    if (ARequestInfo.Command = 'POST') and (Path = '/api/emitir-nfe') then
    begin
      if not ValidateToken(ARequestInfo) then
      begin
        AResponseInfo.ResponseNo := 401;
        AResponseInfo.ContentType := 'application/json';
        AResponseInfo.ContentText := '{"error":"Token de autenticação inválido ou ausente"}';
        LogSecurityEvent('AUTH_FAILED', 'Tentativa de emissão NFe sem token válido - IP: ' + AContext.Binding.PeerIP);
        Exit;
      end;
      
      Body := ReadRequestBody(ARequestInfo);
      // Fallbacks: aceitar JSON via query (json/urlencode) ou base64
      if (Body = '') then
      begin
        try
          var QJson := ARequestInfo.Params.Values['json'];
          if QJson <> '' then
            Body := TIdURI.URLDecode(QJson);
        except end;
        if (Body = '') then
        begin
          try
            var QB64 := ARequestInfo.Params.Values['b64'];
            if QB64 <> '' then
              Body := TEncoding.UTF8.GetString(TNetEncoding.Base64.DecodeStringToBytes(QB64));
          except end;
        end;
      end;
      // Salva payload recebido (debug)
      try
        var LogDir := ExtractFilePath(Application.ExeName) + 'logs\requests\';
        var Name := Format('emitir-nfe-%s.json', [FormatDateTime('yyyymmdd-hhnnss-zzz', Now)]);
        var Full := LogDir + Name;
        var F: TextFile;
        AssignFile(F, Full);
        Rewrite(F);
        try
          Writeln(F, Body);
        finally
          CloseFile(F);
        end;
      except
        // ignora erros de IO
      end;
      Resp := EmitirNFeJSON(Body);
      AResponseInfo.ResponseNo := 200;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := Resp;
      LogSecurityEvent('NFE_EMIT', 'NFe emitida com sucesso - IP: ' + AContext.Binding.PeerIP);
      Exit;
    end;

    if (ARequestInfo.Command = 'POST') and (Path = '/api/cancelar-nfe') then
    begin
      if not ValidateToken(ARequestInfo) then
      begin
        AResponseInfo.ResponseNo := 401;
        AResponseInfo.ContentType := 'application/json';
        AResponseInfo.ContentText := '{"error":"Token de autenticação inválido ou ausente"}';
        LogSecurityEvent('AUTH_FAILED', 'Tentativa de cancelamento NFe sem token válido - IP: ' + AContext.Binding.PeerIP);
        Exit;
      end;
      
      Body := ReadRequestBody(ARequestInfo);
      // Log do request para diagnóstico (como na emissão)
      try
        var LogDir := ExtractFilePath(Application.ExeName) + 'logs\requests\';
        var Name := Format('cancelar-nfe-%s.json', [FormatDateTime('yyyymmdd-hhnnss-zzz', Now)]);
        var Full := LogDir + Name;
        var F: TextFile;
        AssignFile(F, Full);
        Rewrite(F);
        try
          Writeln(F, Body);
        finally
          CloseFile(F);
        end;
      except
        // ignora erros de IO
      end;
      Resp := CancelarNFeJSON(Body);
      AResponseInfo.ResponseNo := 200;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := Resp;
      LogSecurityEvent('NFE_CANCEL', 'NFe cancelada com sucesso - IP: ' + AContext.Binding.PeerIP);
      Exit;
    end;

    if (ARequestInfo.Command = 'POST') and (Path = '/api/carta-correcao') then
    begin
      if not ValidateToken(ARequestInfo) then
      begin
        AResponseInfo.ResponseNo := 401;
        AResponseInfo.ContentType := 'application/json';
        AResponseInfo.ContentText := '{"error":"Token de autenticação inválido ou ausente"}';
        LogSecurityEvent('AUTH_FAILED', 'Tentativa de carta correção sem token válido - IP: ' + AContext.Binding.PeerIP);
        Exit;
      end;
      
      Body := ReadRequestBody(ARequestInfo);
      Resp := CartaCorrecaoJSON(Body);
      AResponseInfo.ResponseNo := 200;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := Resp;
      LogSecurityEvent('NFE_CCE', 'Carta de correção emitida com sucesso - IP: ' + AContext.Binding.PeerIP);
      Exit;
    end;

    if (ARequestInfo.Command = 'POST') and (Path = '/api/inutilizar-nfe') then
    begin
      if not ValidateToken(ARequestInfo) then
      begin
        AResponseInfo.ResponseNo := 401;
        AResponseInfo.ContentType := 'application/json';
        AResponseInfo.ContentText := '{"error":"Token de autenticação inválido ou ausente"}';
        LogSecurityEvent('AUTH_FAILED', 'Tentativa de inutilização NFe sem token válido - IP: ' + AContext.Binding.PeerIP);
        Exit;
      end;
      
      Body := ReadRequestBody(ARequestInfo);
      Resp := InutilizarNFeJSON(Body);
      AResponseInfo.ResponseNo := 200;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := Resp;
      LogSecurityEvent('NFE_INUTIL', 'NFe inutilizada com sucesso - IP: ' + AContext.Binding.PeerIP);
      Exit;
    end;

    if (ARequestInfo.Command = 'POST') and (Path = '/api/emitir-nfse') then
    begin
      if not ValidateToken(ARequestInfo) then
      begin
        AResponseInfo.ResponseNo := 401;
        AResponseInfo.ContentType := 'application/json';
        AResponseInfo.ContentText := '{"error":"Token de autenticação inválido ou ausente"}';
        LogSecurityEvent('AUTH_FAILED', 'Tentativa de emissão NFSe sem token válido - IP: ' + AContext.Binding.PeerIP);
        Exit;
      end;
      
      Body := ReadRequestBody(ARequestInfo);
      Resp := EmitirNFSeJSON(Body);
      AResponseInfo.ResponseNo := 200;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := Resp;
      LogSecurityEvent('NFSE_EMIT', 'NFSe emitida com sucesso - IP: ' + AContext.Binding.PeerIP);
      Exit;
    end;

    // NFC-e endpoint dedicado (aponta para o mesmo fluxo de emissão)
    if (ARequestInfo.Command = 'POST') and (Path = '/api/emitir-nfce') then
    begin
      if not ValidateToken(ARequestInfo) then
      begin
        AResponseInfo.ResponseNo := 401;
        AResponseInfo.ContentType := 'application/json';
        AResponseInfo.ContentText := '{"error":"Token de autenticação inválido ou ausente"}';
        LogSecurityEvent('AUTH_FAILED', 'Tentativa de emissão NFCe sem token válido - IP: ' + AContext.Binding.PeerIP);
        Exit;
      end;
      Body := ReadRequestBody(ARequestInfo);
      if (Body = '') then
      begin
        try
          var QJson := ARequestInfo.Params.Values['json'];
          if QJson <> '' then
            Body := TIdURI.URLDecode(QJson);
        except end;
      end;
      Resp := EmitirNFeJSON(Body);
      AResponseInfo.ResponseNo := 200;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := Resp;
      LogSecurityEvent('NFCE_EMIT', 'NFCe emitida (endpoint dedicado) - IP: ' + AContext.Binding.PeerIP);
      Exit;
    end;

    AResponseInfo.ResponseNo := 404;
    AResponseInfo.ContentType := 'application/json';
    AResponseInfo.ContentText := '{"ok":false,"error":"endpoint não encontrado","method":"' + ARequestInfo.Command + '","path":"' + Path + '"}';
  except
    on E: Exception do
    begin
      AResponseInfo.ResponseNo := 500;
      AResponseInfo.ContentType := 'application/json';
      AResponseInfo.ContentText := '{"ok":false,"error":"' + StringReplace(E.Message, '"', '\"', [rfReplaceAll]) + '"}';
    end;
  end;
end;

function TForm1.EmitirNFSeJSON(const JSONData: string): string;
var
  J, Prestador, Tomador, Rps, Servico: TJSONObject;
  Resp: TJSONObject;
begin
  Resp := TJSONObject.Create;
  try
    try
      J := TJSONObject(TJSONObject.ParseJSONValue(JSONData));
      if not Assigned(J) then
        raise Exception.Create('JSON inválido');

      Prestador := JsonGetObj(J, 'prestador');
      Tomador := JsonGetObj(J, 'tomador');
      Rps := JsonGetObj(J, 'rps');
      Servico := JsonGetObj(J, 'servico');

      if (Prestador = nil) or (Tomador = nil) or (Rps = nil) or (Servico = nil) then
        raise Exception.Create('Campos obrigatórios ausentes (prestador, tomador, rps, servico)');

      // Implementação mínima para validar fluxo. A implementação completa de ACBrNFSe
      // varia conforme provedor e versão. Aqui confirmamos recebimento e retornamos OK.

      Resp.AddPair('ok', TJSONBool.Create(True));
      Resp.AddPair('message', 'NFSe endpoint online. Implementação completa depende do provedor.');
    except
      on E: Exception do
      begin
        Resp.AddPair('ok', TJSONBool.Create(False));
        Resp.AddPair('error', E.Message);
      end;
    end;
    Result := Resp.ToString;
  finally
    Resp.Free;
  end;
end;

function TForm1.InutilizarNFeJSON(const JSONData: string): string;
var
  J: TJSONObject;
  Conf: TJSONObject;
  Resp: TJSONObject;
  emitCNPJ, justificativa: string;
  ano, modelo, serie, nIni, nFim: Integer;
  retXML: string;
  nn: Integer;
  outPath, dirPath, fileName: string;
  customPath: string;
  ambStr: string;
  ambVal: Integer;
  ambEnum: TpcnTipoAmbiente;
  ufStr: string;
  cUF: Integer;
  preInutXML, preInutPath: string;
  tpAmbStr: string;
  function MapUFToCUF(const uf: string): Integer;
  var s: string;
  begin
    s := UpperCase(Trim(uf));
    if s = 'RO' then Exit(11);
    if s = 'AC' then Exit(12);
    if s = 'AM' then Exit(13);
    if s = 'RR' then Exit(14);
    if s = 'PA' then Exit(15);
    if s = 'AP' then Exit(16);
    if s = 'TO' then Exit(17);
    if s = 'MA' then Exit(21);
    if s = 'PI' then Exit(22);
    if s = 'CE' then Exit(23);
    if s = 'RN' then Exit(24);
    if s = 'PB' then Exit(25);
    if s = 'PE' then Exit(26);
    if s = 'AL' then Exit(27);
    if s = 'SE' then Exit(28);
    if s = 'BA' then Exit(29);
    if s = 'MG' then Exit(31);
    if s = 'ES' then Exit(32);
    if s = 'RJ' then Exit(33);
    if s = 'SP' then Exit(35);
    if s = 'PR' then Exit(41);
    if s = 'SC' then Exit(42);
    if s = 'RS' then Exit(43);
    if s = 'MS' then Exit(50);
    if s = 'MT' then Exit(51);
    if s = 'GO' then Exit(52);
    if s = 'DF' then Exit(53);
    Result := 35;
  end;
  function TagVal(const Src, Tag: string): string;
  var o, c: Integer; ot, ct: string;
  begin
    Result := '';
    if Src = '' then Exit;
    ot := '<' + Tag + '>';
    ct := '</' + Tag + '>';
    o := Pos(ot, Src);
    if o > 0 then
    begin
      o := o + Length(ot);
      c := Pos(ct, Src);
      if (c > o) then
        Result := Copy(Src, o, c - o);
    end;
  end;
begin
  Resp := TJSONObject.Create;
  try
    try
      J := TJSONObject(TJSONObject.ParseJSONValue(JSONData));
      if not Assigned(J) then
        raise Exception.Create('JSON inválido');

      emitCNPJ := JsonGetStr(J, 'emit_cnpj', '');
      justificativa := JsonGetStr(J, 'justificativa', '');
      if Length(justificativa) < 15 then
        raise Exception.Create('Justificativa deve ter no mínimo 15 caracteres');

      ano := JsonGetInt(J, 'ano', StrToInt(FormatDateTime('yy', Now)));
      modelo := JsonGetInt(J, 'modelo', 55);
      serie := JsonGetInt(J, 'serie', 1);
      nIni := JsonGetInt(J, 'numero_inicial', 0);
      nFim := JsonGetInt(J, 'numero_final', nIni);

      // Ajusta ambiente/certificado/UF quando informado
      try
        ambStr := LowerCase(Trim(JsonGetStr(J, 'ambiente', '')));
        if ambStr = '' then
        begin
          Conf := JsonGetObj(J, 'configuracoes');
          if Assigned(Conf) then ambStr := LowerCase(Trim(JsonGetStr(Conf, 'ambiente', '')));
        end;
        ambVal := 2;
        if (ambStr = 'producao') or (ambStr = 'producao1') or (ambStr = '1') then ambVal := 1 else ambVal := 2;
        if ambVal = 1 then ambEnum := taProducao else ambEnum := taHomologacao;
        try ACBrNFe1.Configuracoes.WebServices.Ambiente := ambEnum; except end;
        // Certificado via bloco 'cert'
        try
          Conf := JsonGetObj(J, 'cert');
          if Assigned(Conf) then
          begin
            // PFX por caminho/senha
            try ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := JsonGetStr(Conf, 'path', ''); except end;
            try ACBrNFe1.Configuracoes.Certificados.Senha := JsonGetStr(Conf, 'password', ''); except end;
            // Serial (certificado do Windows)
            try ACBrNFe1.Configuracoes.Certificados.NumeroSerie := JsonGetStr(Conf, 'serial', ''); except end;
          end;
        except
        end;
        // UF
        try
          ufStr := JsonGetStr(J, 'uf', '');
          if (ufStr = '') and Assigned(Conf) then ufStr := JsonGetStr(Conf, 'uf', '');
          if ufStr <> '' then
            try ACBrNFe1.Configuracoes.WebServices.UF := ufStr; except end;
        except end;
      except end;

      // Gera e salva XML "pré-inutilização" para diagnóstico de schema
      try
        if ufStr = '' then ufStr := ACBrNFe1.Configuracoes.WebServices.UF;
        if ufStr = '' then ufStr := 'SP';
        cUF := MapUFToCUF(ufStr);
        if ambVal = 1 then tpAmbStr := '1' else tpAmbStr := '2';
        preInutXML := '<?xml version="1.0" encoding="UTF-8"?>' + sLineBreak +
          '<inutNFe xmlns="http://www.portalfiscal.inf.br/nfe" versao="4.00">' + sLineBreak +
          '  <infInut>' + sLineBreak +
          '    <tpAmb>' + tpAmbStr + '</tpAmb>' + sLineBreak +
          '    <xServ>INUTILIZAR</xServ>' + sLineBreak +
          '    <cUF>' + IntToStr(cUF) + '</cUF>' + sLineBreak +
          '    <ano>' + Format('%.2d',[ano]) + '</ano>' + sLineBreak +
          '    <CNPJ>' + DigitsOnly(emitCNPJ) + '</CNPJ>' + sLineBreak +
          '    <mod>' + IntToStr(modelo) + '</mod>' + sLineBreak +
          '    <serie>' + IntToStr(serie) + '</serie>' + sLineBreak +
          '    <nNFIni>' + IntToStr(nIni) + '</nNFIni>' + sLineBreak +
          '    <nNFFin>' + IntToStr(nFim) + '</nNFFin>' + sLineBreak +
          '    <xJust>' + justificativa + '</xJust>' + sLineBreak +
          '  </infInut>' + sLineBreak +
          '</inutNFe>';
        preInutPath := IncludeTrailingPathDelimiter(ExtractFilePath(Application.ExeName) + 'logs\\requests\\') +
          Format('pre_inut_%s_%0.2d_%d_%d_%d-%d_%s.xml', [DigitsOnly(emitCNPJ), ano, modelo, serie, nIni, nFim, FormatDateTime('yyyymmdd_hhnnss', Now)]);
        try ForceDirectories(ExtractFilePath(preInutPath)); except end;
        TFile.WriteAllText(preInutPath, preInutXML, TEncoding.UTF8);
      except
      end;

      // Chama inutilização; usa WebServices.Inutilizacao para garantir tpAmb/UF/serie corretos
      if nFim > nIni then
      begin
        retXML := '';
        for nn := nIni to nFim do
        begin
          try
            try
              // Algumas versões do ACBr esperam a ordem (CNPJ, Just, Ano, Serie, Modelo, Numero)
              ACBrNFe1.Configuracoes.WebServices.UF := ufStr;
              // Log de parâmetros de inutilização
              try LogSecurityEvent('NFE_INUT_CALL', Format('CNPJ=%s Ano=%d Modelo=%d Serie=%d Num=%d Amb=%s UF=%s',[DigitsOnly(emitCNPJ), ano, modelo, serie, nn, ambStr, ufStr])); except end;
              // ACBr Trunk2: usar WebServices.Inutiliza(CNPJ, Just, Ano, Modelo, Serie, NumIni, NumFim)
              ACBrNFe1.WebServices.Inutiliza(DigitsOnly(emitCNPJ), justificativa, ano, 55, serie, nn, nn);
              try
                retXML := ACBrNFe1.WebServices.Inutilizacao.RetWS;
              except
                // mantém último retXML válido
              end;
            except
              // segue para próximo número
            end
          except
            // continua tentando os próximos, mas reporta erro ao final via cStat/xMotivo quando possível
          end;
        end;
      end
      else
      begin
        try
          ACBrNFe1.Configuracoes.WebServices.UF := ufStr;
          try LogSecurityEvent('NFE_INUT_CALL', Format('CNPJ=%s Ano=%d Modelo=%d Serie=%d Num=%d Amb=%s UF=%s',[DigitsOnly(emitCNPJ), ano, modelo, serie, nIni, ambStr, ufStr])); except end;
          // ACBr Trunk2: usar WebServices.Inutiliza(CNPJ, Just, Ano, Modelo, Serie, NumIni, NumFim)
          ACBrNFe1.WebServices.Inutiliza(DigitsOnly(emitCNPJ), justificativa, ano, 55, serie, nIni, nIni);
          try
            retXML := ACBrNFe1.WebServices.Inutilizacao.RetWS;
          except
            retXML := '';
          end;
        except
          retXML := '';
        end;
      end;

      Resp.AddPair('ok', TJSONBool.Create(True));
      if retXML <> '' then
      begin
        Resp.AddPair('xml_retorno', retXML);
        // Extrai cStat/xMotivo do XML de retorno
        try
          Resp.AddPair('cStat', TagVal(retXML, 'cStat'));
          Resp.AddPair('xMotivo', TagVal(retXML, 'xMotivo'));
        except end;
        // Grava arquivo no diretório padrão ao lado do executável e opcionalmente no path recebido em configuracoes.path_xml
        try
          dirPath := IncludeTrailingPathDelimiter(ExtractFilePath(Application.ExeName) + 'nfe');
          try ForceDirectories(dirPath); except end;
          fileName := Format('inut_%s_%0.2d_%d_%d_%d-%d.xml', [DigitsOnly(emitCNPJ), ano, modelo, serie, nIni, nFim]);
          outPath := dirPath + fileName;
          TFile.WriteAllText(outPath, retXML, TEncoding.UTF8);
          if FileExists(outPath) then
            Resp.AddPair('xml_path', outPath);
        except end;
        // Extra: grava também em configuracoes.path_xml, se informado
        try
          Conf := JsonGetObj(J, 'configuracoes');
          if Assigned(Conf) then
          begin
            customPath := JsonGetStr(Conf, 'path_xml', '');
            if customPath <> '' then
            begin
              if (customPath[Length(customPath)] <> '\\') and (customPath[Length(customPath)] <> '/') then
                customPath := IncludeTrailingPathDelimiter(customPath);
              try ForceDirectories(customPath); except end;
              try
                TFile.WriteAllText(customPath + fileName, retXML, TEncoding.UTF8);
              except end;
            end;
          end;
        except end;
      end
      else
      begin
        // Tenta informar cStat/xMotivo mesmo sem XML
        try Resp.AddPair('cStat', IntToStr(ACBrNFe1.WebServices.Inutilizacao.CStat)); except end;
        try Resp.AddPair('xMotivo', ACBrNFe1.WebServices.Inutilizacao.XMotivo); except end;
        // Retorna caminho do pré-XML para análise
        try if preInutPath <> '' then Resp.AddPair('pre_inut_xml_path', preInutPath); except end;
        if (not Resp.GetValue<Boolean>('ok')) or ((Resp.GetValue<string>('cStat') = '') and (Resp.GetValue<string>('xMotivo') = '')) then
        begin
          try Resp.RemovePair('ok').Free; except end;
          Resp.AddPair('ok', TJSONBool.Create(False));
          Resp.AddPair('error', 'SEM_RETORNO_INUTILIZACAO');
        end;
      end;
    except
      on E: Exception do
      begin
        Resp.AddPair('ok', TJSONBool.Create(False));
        Resp.AddPair('error', E.Message);
      end;
    end;
    Result := Resp.ToString;
  finally
    Resp.Free;
  end;
end;

function TForm1.EmitirNFeJSON(const JSONData: string): string;
var
  J, EmitObj, DestObj, Conf, ItemObj: TJSONObject;
  Itens: TJSONArray;
  i: Integer;
  XMLPath, PDFPath, Protocolo, Chave: string;
  Resp: TJSONObject;
  PreXMLPath: string;
  BuildPhase: string;
  DebugXML: string;
  TmpXMLPath: string;
  JSONText: string;
  TotalProdutos: Double;
  TevePagamento: Boolean;
  IsConsumidorFinal: Boolean;
  IsNFCE: Boolean;
  ICMSBaseTotal: Double;
  ICMSValorTotal: Double;
  GeneratePDF: Boolean;
  function Round2(const x: Double): Double;
  begin
    if x >= 0 then Result := Trunc(x * 100.0 + 0.5) / 100.0
    else Result := -Trunc(-x * 100.0 + 0.5) / 100.0;
  end;
  function SaveBase64ToFile(const Base64Data, TargetPath: string): Boolean;
  var bytes: TBytes;
  begin
    Result := False;
    try
      if (Base64Data = '') or (TargetPath = '') then Exit;
      bytes := TNetEncoding.Base64.DecodeStringToBytes(Base64Data);
      try ForceDirectories(ExtractFilePath(TargetPath)); except end;
      TFile.WriteAllBytes(TargetPath, bytes);
      Result := FileExists(TargetPath);
    except
      Result := False;
    end;
  end;
  function GetCUFForUF(const uf: string): Integer;
  var s: string;
  begin
    s := UpperCase(Trim(uf));
    if s = 'RO' then Exit(11);
    if s = 'AC' then Exit(12);
    if s = 'AM' then Exit(13);
    if s = 'RR' then Exit(14);
    if s = 'PA' then Exit(15);
    if s = 'AP' then Exit(16);
    if s = 'TO' then Exit(17);
    if s = 'MA' then Exit(21);
    if s = 'PI' then Exit(22);
    if s = 'CE' then Exit(23);
    if s = 'RN' then Exit(24);
    if s = 'PB' then Exit(25);
    if s = 'PE' then Exit(26);
    if s = 'AL' then Exit(27);
    if s = 'SE' then Exit(28);
    if s = 'BA' then Exit(29);
    if s = 'MG' then Exit(31);
    if s = 'ES' then Exit(32);
    if s = 'RJ' then Exit(33);
    if s = 'SP' then Exit(35);
    if s = 'PR' then Exit(41);
    if s = 'SC' then Exit(42);
    if s = 'RS' then Exit(43);
    if s = 'MS' then Exit(50);
    if s = 'MT' then Exit(51);
    if s = 'GO' then Exit(52);
    if s = 'DF' then Exit(53);
    Result := 35; // padrão SP
  end;
  function FileToBase64(const APath: string): string;
  var bytes: TBytes;
  begin
    Result := '';
    try
      if (APath <> '') and FileExists(APath) then
      begin
        bytes := TFile.ReadAllBytes(APath);
        Result := TNetEncoding.Base64.EncodeBytesToString(bytes);
      end;
    except
      Result := '';
    end;
  end;
  function TagVal(const Src, Tag: string): string;
  var o, c: Integer; ot, ct: string;
  begin
    Result := '';
    ot := '<' + Tag + '>';
    ct := '</' + Tag + '>';
    o := Pos(ot, Src);
    if o > 0 then
    begin
      o := o + Length(ot);
      c := Pos(ct, Src);
      if (c > o) then
        Result := Copy(Src, o, c - o);
    end;
  end;
  procedure AttachPreXMLBase64;
  var TempPath, Tmp: string;
  begin
    try
      if ACBrNFe1.NotasFiscais.Count = 0 then Exit;
      // 1) Se já temos um PreXMLPath salvo, usa ele
      if (PreXMLPath <> '') and FileExists(PreXMLPath) then
      begin
        Resp.AddPair('pre_xml_b64', FileToBase64(PreXMLPath));
        Exit;
      end;
      // 2) Tenta salvar no caminho padrão
      try
        PreXMLPath := ExtractFilePath(Application.ExeName) + 'logs\\requests\\pre_envio_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
        try ForceDirectories(ExtractFilePath(PreXMLPath)); except end;
        ACBrNFe1.NotasFiscais.Items[0].GravarXML(PreXMLPath);
        if FileExists(PreXMLPath) then
        begin
          Resp.AddPair('pre_xml_b64', FileToBase64(PreXMLPath));
          Exit;
        end;
      except
      end;
      // 3) Tenta salvar no diretório temporário do SO
      try
        TempPath := TPath.GetTempPath;
        Tmp := IncludeTrailingPathDelimiter(TempPath) + 'pre_envio_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
        ACBrNFe1.NotasFiscais.Items[0].GravarXML(Tmp);
        if FileExists(Tmp) then
        begin
          Resp.AddPair('pre_xml_b64', FileToBase64(Tmp));
          try DeleteFile(PChar(Tmp)); except end;
          Exit;
        end;
      except
      end;
    except
      on E: Exception do
      begin
        try Resp.AddPair('pre_xml_error', E.Message); except end;
      end;
    end;
  end;
begin
  Resp := TJSONObject.Create;
  try
    try
      BuildPhase := 'start';
      J := TJSONObject(TJSONObject.ParseJSONValue(JSONData));
      if not Assigned(J) then
        raise Exception.Create('JSON inválido');

      // Certificado (opcional)
      Conf := JsonGetObj(J, 'cert');
      if Assigned(Conf) then
      begin
        // Se vier número de série, priorizar uso do certificado instalado
        if JsonGetStr(Conf, 'serial', '') <> '' then
        begin
          ACBrNFe1.Configuracoes.Certificados.NumeroSerie := JsonGetStr(Conf, 'serial', '');
          // Limpar PFX para evitar conflito
          ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := '';
          ACBrNFe1.Configuracoes.Certificados.Senha := '';
        end
        else
        begin
          // Fallback: arquivo PFX + senha
          ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := AnsiString(JsonGetStr(Conf, 'path'));
          ACBrNFe1.Configuracoes.Certificados.Senha := AnsiString(JsonGetStr(Conf, 'password'));
          if (ACBrNFe1.Configuracoes.Certificados.ArquivoPFX = '') or
             (not FileExists(ACBrNFe1.Configuracoes.Certificados.ArquivoPFX)) then
            raise Exception.Create('Certificado PFX não encontrado: ' + ACBrNFe1.Configuracoes.Certificados.ArquivoPFX);

          // Carregamento ocorrerá automaticamente durante a assinatura/envio
        end;
      end;

      // Configurações
      Conf := JsonGetObj(J, 'configuracoes');
      if Assigned(Conf) then
      begin
        ACBrNFe1.Configuracoes.WebServices.UF := JsonGetStr(Conf, 'uf', 'SP');
        // Ambiente: deixar padrão configurado no ACBr para evitar dependência de constantes
        XMLPath := JsonGetStr(Conf, 'path_xml', '');
        if XMLPath <> '' then
          ACBrNFe1.Configuracoes.Arquivos.PathNFe := IncludeTrailingPathDelimiter(XMLPath);
        XMLPath := JsonGetStr(Conf, 'path_schemas', '');
        if XMLPath <> '' then
          ACBrNFe1.Configuracoes.Arquivos.PathSchemas := IncludeTrailingPathDelimiter(XMLPath);

        // Flag para geração de PDF do DANFE (default: false)
        try GeneratePDF := SameText(Trim(JsonGetStr(Conf, 'gerar_pdf', 'false')), 'true'); except GeneratePDF := False; end;

        // DANFE Logo: desabilitado por padrão (evitar WIC). Aceita apenas BMP explícito.
        try
          ACBrNFeDANFeRL1.Logo := '';
          var LogoPath := JsonGetStr(Conf, 'logo_path', '');
          if (LogoPath <> '') and FileExists(LogoPath) then
          begin
            var Ext := UpperCase(ExtractFileExt(LogoPath));
            if Ext = '.BMP' then
              try ACBrNFeDANFeRL1.Logo := LogoPath; except ACBrNFeDANFeRL1.Logo := ''; end
            else
              ACBrNFeDANFeRL1.Logo := '';
          end;
        except
          try ACBrNFeDANFeRL1.Logo := ''; except end;
        end;
      end;

      BuildPhase := 'building';
      ACBrNFe1.NotasFiscais.Clear;
      IsConsumidorFinal := False;
      ICMSBaseTotal := 0.0;
      ICMSValorTotal := 0.0;
      with ACBrNFe1.NotasFiscais.Add.NFe do
      begin
        // IDE
        IsNFCE := False;
        try
          var CfgIde := JsonGetObj(J, 'configuracoes');
          var ModeloCfg := 0;
          if Assigned(CfgIde) then ModeloCfg := JsonGetInt(CfgIde, 'modelo', 0);
          if ModeloCfg = 65 then
          begin
            Ide.modelo := 65;
            IsNFCE := True;
          end
          else
            Ide.modelo := 55;
        except
          Ide.modelo := 55;
        end;
        Ide.serie := JsonGetInt(J, 'serie', 1);
        // Suporta 'numero' e 'numero_nfe' no JSON (prioriza numero_nfe)
        var nNF := JsonGetInt(J, 'numero_nfe', 0);
        if (nNF <= 0) then
          nNF := JsonGetInt(J, 'numero', 0);
        if (nNF <= 0) then
        begin
          var np := DigitsOnly(JsonGetStr(J, 'numero_pedido',''));
          if (np <> '') then
          begin
            var startIdx := Length(np) - 8;
            if startIdx < 1 then startIdx := 1;
            nNF := StrToIntDef(Copy(np, startIdx, 9), 0);
          end;
          if (nNF <= 0) then nNF := 1;
        end;
        Ide.nNF := nNF;
        // Ide.tpNF, Ide.tpEmis e Ide.procEmi mantidos padrão para ampla compatibilidade
        Ide.natOp := JsonGetStr(J, 'natOp', 'Venda de mercadoria');
        Ide.verProc := 'QFiscal-Delphi-1.0';
        // Datas: mantidas padrão; ajustes feitos no XML pós-gravação
        // cUF/cMunFG se informados
        try
          var ufIde := JsonGetStr(JsonGetObj(J, 'emitente'), 'uf', '');
          if ufIde = '' then ufIde := JsonGetStr(JsonGetObj(J, 'configuracoes'), 'uf', '');
          if ufIde <> '' then Ide.cUF := GetCUFForUF(ufIde);
        except end;
        // cMunFG se informado nas configurações
        try
          var cMunFG := JsonGetInt(JsonGetObj(J, 'configuracoes'), 'cMunFG', 0);
          if cMunFG > 0 then Ide.cMunFG := cMunFG;
        except end;

        // Emitente
        EmitObj := JsonGetObj(J, 'emitente');
        if Assigned(EmitObj) then
        begin
          Emit.CNPJCPF := DigitsOnly(JsonGetStr(EmitObj, 'cnpj',''));
          Emit.IE := DigitsOnly(JsonGetStr(EmitObj, 'ie',''));
          Emit.xNome := JsonGetStr(EmitObj, 'razao_social','');
          Emit.xFant := JsonGetStr(EmitObj, 'nome_fantasia','');
          Emit.EnderEmit.xLgr := JsonGetStr(EmitObj, 'endereco','');
          Emit.EnderEmit.nro := JsonGetStr(EmitObj, 'numero','');
          Emit.EnderEmit.xCpl := JsonGetStr(EmitObj, 'complemento','');
          Emit.EnderEmit.xBairro := JsonGetStr(EmitObj, 'bairro','');
          Emit.EnderEmit.cMun := StrToIntDef(JsonGetStr(EmitObj, 'codigo_ibge','0'), 0);
          if Emit.EnderEmit.cMun = 0 then
            Emit.EnderEmit.cMun := StrToIntDef(JsonGetStr(EmitObj, 'codigo_municipio','0'), 0);
          Emit.EnderEmit.xMun := JsonGetStr(EmitObj, 'cidade','');
          Emit.EnderEmit.UF := JsonGetStr(EmitObj, 'uf','SP');
          Emit.EnderEmit.CEP := StrToIntDef(DigitsOnly(JsonGetStr(EmitObj, 'cep','0')), 0);
          // CRT: manter padrão configurado no ACBr para compatibilidade entre versões
        end;

        // Destinatário
        DestObj := JsonGetObj(J, 'cliente');
        if Assigned(DestObj) then
        begin
          var Doc := DigitsOnly(JsonGetStr(DestObj, 'cpf_cnpj',''));
          if (Length(Doc) = 11) or (Length(Doc) = 14) then
            Dest.CNPJCPF := Doc
          else
            Dest.CNPJCPF := '';
          Dest.xNome := JsonGetStr(DestObj, 'nome','');
          Dest.IE := JsonGetStr(DestObj, 'ie','');
          if Dest.IE = '' then
            Dest.indIEDest := inNaoContribuinte
          else
            Dest.indIEDest := inContribuinte;
          // Marca consumidor final quando IE vazio ou flag explícita no JSON
          try
            var consFlag := UpperCase(Trim(JsonGetStr(DestObj, 'consumidor_final', '')));
            if (Dest.IE = '') or (consFlag = 'S') or (consFlag = 'SIM') or (consFlag = '1') then
              IsConsumidorFinal := True;
          except end;
          Dest.EnderDest.xLgr := JsonGetStr(DestObj, 'endereco','');
          Dest.EnderDest.nro := JsonGetStr(DestObj, 'numero','');
          Dest.EnderDest.xBairro := JsonGetStr(DestObj, 'bairro','');
          Dest.EnderDest.cMun := StrToIntDef(JsonGetStr(DestObj, 'codigo_ibge','0'), 0);
          if Dest.EnderDest.cMun = 0 then
            Dest.EnderDest.cMun := StrToIntDef(JsonGetStr(DestObj, 'codigo_municipio','0'), 0);
          Dest.EnderDest.xMun := JsonGetStr(DestObj, 'cidade','');
          Dest.EnderDest.UF := JsonGetStr(DestObj, 'uf','');
          Dest.EnderDest.CEP := StrToIntDef(DigitsOnly(JsonGetStr(DestObj, 'cep','0')), 0);
        end;

        // Itens
        TotalProdutos := 0.0;
        Itens := JsonGetArr(J, 'produtos');
        if Assigned(Itens) then
        begin
          for i := 0 to Itens.Count - 1 do
          begin
            ItemObj := Itens.Items[i] as TJSONObject;
            with Det.New do
            begin
              Prod.nItem := i+1;
              Prod.cProd := JsonGetStr(ItemObj, 'codigo', '');
              Prod.xProd := JsonGetStr(ItemObj, 'nome', '');
              Prod.NCM := JsonGetStr(ItemObj, 'ncm', '');
              Prod.CFOP := JsonGetStr(ItemObj, 'cfop', '5102');
              Prod.uCom := JsonGetStr(ItemObj, 'unidade', 'UN');
              Prod.qCom := StrToFloatDef(JsonGetStr(ItemObj, 'quantidade', '1'), 1.0);
              Prod.vUnCom := StrToFloatDef(JsonGetStr(ItemObj, 'valor_unitario', '0'), 0.0);
              Prod.vProd := StrToFloatDef(JsonGetStr(ItemObj, 'valor_total', ''), Prod.qCom * Prod.vUnCom);
              // Desconto por item (para evitar rejeição: Total do Desconto difere do somatório dos itens)
              try Prod.vDesc := StrToFloatDef(JsonGetStr(ItemObj, 'vDesc', '0'), 0); except end;
              try TotalProdutos := TotalProdutos + Prod.vProd; except end;
              // Normalização do GTIN: aceitar somente numérico válido ou 'SEM GTIN'
              var EANVal := Trim(JsonGetStr(ItemObj, 'ean', ''));
              if EANVal = '' then EANVal := Trim(JsonGetStr(ItemObj, 'codigo_barras', ''));
              var EANUp := UpperCase(EANVal);
              if (EANUp = 'SEM GTIN') or (EANUp = 'SEMGTIN') then
                EANVal := 'SEM GTIN'
              else
              begin
                var digits := DigitsOnly(EANVal);
                if (Length(digits) in [0,8,12,13,14]) then
                  EANVal := digits
                else
                  EANVal := 'SEM GTIN';
              end;
              Prod.cEAN := EANVal;
              Prod.cEANTrib := EANVal;
              Prod.uTrib := Prod.uCom;
              Prod.qTrib := Prod.qCom;
              Prod.vUnTrib := Prod.vUnCom;
              // Impostos ICMS: deixar ACBr determinar/grupo conforme configuração do emissor
              // IndTot: remover para compatibilidade ampla em versões antigas do ACBr

              // ===== Mapear impostos no ACBr a partir dos valores do JSON =====
              try
              begin
                var BaseICMS    : Double := StrToFloatDef(JsonGetStr(ItemObj, 'base_icms', '0'), 0);
                var AliqICMS    : Double := StrToFloatDef(JsonGetStr(ItemObj, 'aliquota_icms', '0'), 0);
                var ValorICMS   : Double := StrToFloatDef(JsonGetStr(ItemObj, 'valor_icms', '0'), 0);
                // var CSTICMS  : string := JsonGetStr(ItemObj, 'cst_icms', '00');
                // var OrigemStr: string := JsonGetStr(ItemObj, 'origem', '0');

                var AliqPIS     : Double := StrToFloatDef(JsonGetStr(ItemObj, 'aliquota_pis', '0'), 0);
                var ValorPIS    : Double := StrToFloatDef(JsonGetStr(ItemObj, 'valor_pis', '0'), 0);
                // var CSTPIS   : string := JsonGetStr(ItemObj, 'cst_pis', '01');

                var AliqCOFINS  : Double := StrToFloatDef(JsonGetStr(ItemObj, 'aliquota_cofins', '0'), 0);
                var ValorCOFINS : Double := StrToFloatDef(JsonGetStr(ItemObj, 'valor_cofins', '0'), 0);
                // var CSTCOFINS: string := JsonGetStr(ItemObj, 'cst_cofins', '01');

                // ICMS (grupo básico) - preencher CST e origem com defaults seguros
                try
                begin
                  var cstIcmsStr := JsonGetStr(ItemObj, 'cst_icms', '00');
                  if cstIcmsStr = '00' then Imposto.ICMS.CST := cst00
                  else if cstIcmsStr = '10' then Imposto.ICMS.CST := cst10
                  else if cstIcmsStr = '20' then Imposto.ICMS.CST := cst20
                  else if cstIcmsStr = '30' then Imposto.ICMS.CST := cst30
                  else if cstIcmsStr = '40' then Imposto.ICMS.CST := cst40
                  else if cstIcmsStr = '41' then Imposto.ICMS.CST := cst41
                  else if cstIcmsStr = '50' then Imposto.ICMS.CST := cst50
                  else if cstIcmsStr = '51' then Imposto.ICMS.CST := cst51
                  else if cstIcmsStr = '60' then Imposto.ICMS.CST := cst60
                  else if cstIcmsStr = '70' then Imposto.ICMS.CST := cst70
                  else if cstIcmsStr = '90' then Imposto.ICMS.CST := cst90
                  else Imposto.ICMS.CST := cst00;
                end; except end;
                // Origem: usa default seguro para evitar dependência de enums ausentes na build
                try Imposto.ICMS.orig := oeNacional; except end;

                // Campos numéricos: garantir consistência com vICMS = vBC * pICMS
                Imposto.ICMS.vBC   := BaseICMS;
                Imposto.ICMS.pICMS := AliqICMS;
                Imposto.ICMS.vICMS := Round2(BaseICMS * (AliqICMS / 100.0));
                try
                  ICMSBaseTotal  := ICMSBaseTotal + Imposto.ICMS.vBC;
                  ICMSValorTotal := ICMSValorTotal + Imposto.ICMS.vICMS;
                except end;

                // PIS (alíquota)
                try
                begin
                  var cstPisStr := JsonGetStr(ItemObj, 'cst_pis', '01');
                  if cstPisStr = '49' then Imposto.PIS.CST := pis49
                  else if cstPisStr = '01' then Imposto.PIS.CST := pis01
                  else if cstPisStr = '02' then Imposto.PIS.CST := pis02
                  else Imposto.PIS.CST := pis01;
                end; except end;
                Imposto.PIS.vBC  := BaseICMS;
                Imposto.PIS.pPIS := AliqPIS;
                Imposto.PIS.vPIS := ValorPIS;

                // COFINS (alíquota)
                try
                begin
                  var cstCofStr := JsonGetStr(ItemObj, 'cst_cofins', '01');
                  if cstCofStr = '49' then Imposto.COFINS.CST := cof49
                  else if cstCofStr = '01' then Imposto.COFINS.CST := cof01
                  else if cstCofStr = '02' then Imposto.COFINS.CST := cof02
                  else Imposto.COFINS.CST := cof01;
                end; except end;
                Imposto.COFINS.vBC     := BaseICMS;
                Imposto.COFINS.pCOFINS := AliqCOFINS;
                Imposto.COFINS.vCOFINS := ValorCOFINS;
              end;
              except
                // Se algo falhar no mapeamento, deixa ACBr calcular/validar conforme configuração
              end;
            end;
          end;
        end;

        // Transporte (somente quando necessário)
        begin
          var TranspObj := JsonGetObj(J, 'transporte');
          if Assigned(TranspObj) then
          begin
            var fm := StrToIntDef(JsonGetStr(TranspObj, 'modalidade', '9'), 9);
            // Deixa modFrete conforme configuração padrão do ACBr para evitar dependência de enum na build
            var VolObj := JsonGetObj(TranspObj, 'volumes');
            var explicit := Assigned(VolObj);
            if (fm <> 9) or explicit then
            begin
              with Transp.Vol.New do
              begin
                qVol := StrToIntDef(JsonGetStr(VolObj, 'quantidade', '1'), 1);
                if qVol < 1 then qVol := 1;
                esp := JsonGetStr(VolObj, 'especie', 'VOL');
                pesoB := StrToFloatDef(JsonGetStr(VolObj, 'peso_bruto', '0.1'), 0.1);
                if pesoB <= 0 then pesoB := 0.1;
                pesoL := StrToFloatDef(JsonGetStr(VolObj, 'peso_liquido', '0.1'), 0.1);
                if pesoL <= 0 then pesoL := 0.1;
              end;
            end;
          end;
        end;

        // Pagamentos (NFe 4.00)
        begin
          TevePagamento := False;
          var Pays := JsonGetArr(J, 'pagamentos');
          if Assigned(Pays) then
          begin
            var pj: Integer;
            for pj := 0 to Pays.Count - 1 do
            begin
              var PayObj := Pays.Items[pj] as TJSONObject;
              try
                // Cria detPag e define tPag por RTTI para compatibilidade de versões
                with pag.New do
                begin
                  // Define tPag com base no JSON (aceita 'tPag' ou 'forma')
                  var tPagStr := Trim(JsonGetStr(PayObj, 'tPag', ''));
                  if tPagStr = '' then tPagStr := Trim(JsonGetStr(PayObj, 'forma', '01'));
                  // Define tPag convertendo código para enum (TpcnFormaPagamento)
                  try tPag := TpcnFormaPagamento(StrToIntDef(tPagStr, 1)); except end;
                  vPag := StrToFloatDef(JsonGetStr(PayObj, 'valor', '0'), 0.0);
                end;
                try PayItem.vPag := StrToFloatDef(JsonGetStr(PayObj, 'valor', '0'), 0.0); except end;
              except
              end;
                TevePagamento := True;
              except
              end;
            end;
            // vTroco opcional
            try
            begin
              var vTrocoStr := JsonGetStr(J, 'vTroco', '');
              if vTrocoStr <> '' then
                try pag.vTroco := StrToFloatDef(vTrocoStr, 0.0); except end;
            end; except end;
          end;
          // Garantia: se não veio pagamento, cria um com valor total dos produtos
          if not TevePagamento then
          begin
            try
              var PayDef := pag.New;
              try SetOrdProp(PayDef, 'tPag', 1); except try SetStrProp(PayDef, 'tPag', '01'); except end; end;
              try if TotalProdutos > 0 then PayDef.vPag := TotalProdutos else PayDef.vPag := 0.01; except end;
            except end;
          end;
        end;
      end; // with NFe
      BuildPhase := 'built';

      // Totais (se enviados no JSON) para evitar falhas de nós nulos
      try
        var TotObj := JsonGetObj(J, 'totais');
        if Assigned(TotObj) and (ACBrNFe1.NotasFiscais.Count > 0) then
        begin
          with ACBrNFe1.NotasFiscais.Items[0].NFe.Total do
          begin
            // ICMSTot completo quando disponível
            var IcmsTotObj := JsonGetObj(TotObj, 'ICMSTot');
            if Assigned(IcmsTotObj) then
            begin
              ICMSTot.vBC        := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vBC', '0'), 0);
              ICMSTot.vICMS      := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vICMS', '0'), 0);
              ICMSTot.vICMSDeson := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vICMSDeson', '0'), 0);
              ICMSTot.vFCP       := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vFCP', '0'), 0);
              ICMSTot.vBCST      := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vBCST', '0'), 0);
              ICMSTot.vST        := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vST', '0'), 0);
              ICMSTot.vFCPST     := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vFCPST', '0'), 0);
              ICMSTot.vFCPSTRet  := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vFCPSTRet', '0'), 0);
              ICMSTot.vProd      := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vProd', '0'), 0);
              ICMSTot.vFrete     := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vFrete', '0'), 0);
              ICMSTot.vSeg       := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vSeg', '0'), 0);
              ICMSTot.vDesc      := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vDesc', '0'), 0);
              ICMSTot.vII        := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vII', '0'), 0);
              ICMSTot.vIPI       := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vIPI', '0'), 0);
              ICMSTot.vIPIDevol  := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vIPIDevol', '0'), 0);
              ICMSTot.vPIS       := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vPIS', '0'), 0);
              ICMSTot.vCOFINS    := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vCOFINS', '0'), 0);
              ICMSTot.vOutro     := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vOutro', '0'), 0);
              ICMSTot.vNF        := StrToFloatDef(JsonGetStr(IcmsTotObj, 'vNF', '0'), 0);
            end
            else
            begin
              // Fallback com campos de Totais no nível superior
              ICMSTot.vProd  := StrToFloatDef(JsonGetStr(TotObj, 'vProd', '0'), 0);
              ICMSTot.vDesc  := StrToFloatDef(JsonGetStr(TotObj, 'vDesc', '0'), 0);
              ICMSTot.vFrete := StrToFloatDef(JsonGetStr(TotObj, 'vFrete', '0'), 0);
              ICMSTot.vSeg   := StrToFloatDef(JsonGetStr(TotObj, 'vSeg', '0'), 0);
              ICMSTot.vOutro := StrToFloatDef(JsonGetStr(TotObj, 'vOutro', '0'), 0);
              ICMSTot.vNF    := StrToFloatDef(JsonGetStr(TotObj, 'vNF', '0'), 0);
            end;
          end;
        end
        else if (ACBrNFe1.NotasFiscais.Count > 0) then
        begin
          // Fallback: se não vierem totais, preenche mínimos com base no somatório de produtos
          try
            with ACBrNFe1.NotasFiscais.Items[0].NFe.Total do
            begin
              ICMSTot.vProd := TotalProdutos;
              if ICMSTot.vNF = 0 then ICMSTot.vNF := TotalProdutos;
            end;
          except end;
        end;
        // Em qualquer caso, sincroniza ICMSTot com o somatório dos itens (evita rejeição de BC/ICMS)
        try
          with ACBrNFe1.NotasFiscais.Items[0].NFe.Total do
          begin
            ICMSTot.vBC   := Round2(ICMSBaseTotal);
            ICMSTot.vICMS := Round2(ICMSValorTotal);
            if ICMSTot.vProd = 0 then ICMSTot.vProd := Round2(TotalProdutos);
            if ICMSTot.vNF = 0 then ICMSTot.vNF := Round2(TotalProdutos);
          end;
        except
        end;
      except
      end;

      // Dump do XML de pré-envio para diagnóstico
      try
        BuildPhase := 'pre_save_xml';
        PreXMLPath := ExtractFilePath(Application.ExeName) + 'logs\\requests\\pre_envio_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
        // Garante diretório
        try ForceDirectories(ExtractFilePath(PreXMLPath)); except end;
        if ACBrNFe1.NotasFiscais.Count > 0 then
        begin
          ACBrNFe1.NotasFiscais.Items[0].GravarXML(PreXMLPath);
          // Grava também uma cópia alternativa para facilitar inspeção
          try
            var AltDir := 'C:\\Users\\g5poa\\OneDrive\\Documentos\\xml\\';
            var AltPath := AltDir + 'pre_envio_latest.xml';
            if not DirectoryExists(AltDir) then ForceDirectories(AltDir);
            ACBrNFe1.NotasFiscais.Items[0].GravarXML(AltPath);
            try TFile.Copy(PreXMLPath, AltPath, True); except end;
            Resp.AddPair('pre_xml_path_alt', AltPath);
          except
          end;
        end;
        // Tenta anexar em base64 de qualquer maneira
        AttachPreXMLBase64;
      except
        BuildPhase := 'pre_save_xml_error';
        PreXMLPath := '';
        // Retorna XML inline em base64
        AttachPreXMLBase64;
      end;

      // Ajustes de NFC-e no XML antes do envio: dhEmi atual, indPres=1, tpImp=4
      try
        if (PreXMLPath <> '') and FileExists(PreXMLPath) then
        begin
          var XmlTxt := TFile.ReadAllText(PreXMLPath, TEncoding.UTF8);
          // Atualiza dhEmi
          var tz := '-03:00';
          // Formata data/hora local no padrão YYYY-MM-DDThh:nn:ss-03:00
          var dt := FormatDateTime('yyyy-mm-dd"T"hh:nn:ss', Now) + tz;
          if Pos('<dhEmi>', XmlTxt) > 0 then
          begin
            var p1 := Pos('<dhEmi>', XmlTxt);
            var p2 := Pos('</dhEmi>', XmlTxt);
            if (p1 > 0) and (p2 > p1) then
            begin
              var prefix := Copy(XmlTxt, 1, p1 + Length('<dhEmi>') - 1);
              var suffix := Copy(XmlTxt, p2, MaxInt);
              XmlTxt := prefix + dt + suffix;
            end;
          end
          else
          begin
            // Insere dhEmi antes de </ide>
            if Pos('</ide>', XmlTxt) > 0 then
              XmlTxt := StringReplace(XmlTxt, '</ide>', '<dhEmi>' + dt + '</dhEmi></ide>', []);
          end;
          // NFC-e: indPres=1 e tpImp=4
          if IsNFCE then
          begin
            XmlTxt := StringReplace(XmlTxt, '<indPres>0</indPres>', '<indPres>1</indPres>', [rfReplaceAll]);
            XmlTxt := StringReplace(XmlTxt, '<tpImp>1</tpImp>', '<tpImp>4</tpImp>', [rfReplaceAll]);
            if Pos('<indPres>', XmlTxt) = 0 then
              XmlTxt := StringReplace(XmlTxt, '</ide>', '<indPres>1</indPres></ide>', []);
            if Pos('<tpImp>', XmlTxt) = 0 then
              XmlTxt := StringReplace(XmlTxt, '</ide>', '<tpImp>4</tpImp></ide>', []);
            // NFC-e: sem frete — força modFrete=9 se presente, ou injeta se necessário
            XmlTxt := StringReplace(XmlTxt, '<modFrete>0</modFrete>', '<modFrete>9</modFrete>', [rfReplaceAll]);
            if (Pos('<transp>', XmlTxt) > 0) and (Pos('<modFrete>', XmlTxt) = 0) then
              XmlTxt := StringReplace(XmlTxt, '<transp>', '<transp><modFrete>9</modFrete>', []);
          end;
          // Garante indFinal=1
          XmlTxt := StringReplace(XmlTxt, '<indFinal>0</indFinal>', '<indFinal>1</indFinal>', [rfReplaceAll]);
          TFile.WriteAllText(PreXMLPath, XmlTxt, TEncoding.UTF8);
          // Recarrega XML ajustado
          ACBrNFe1.NotasFiscais.Clear;
          ACBrNFe1.NotasFiscais.LoadFromFile(PreXMLPath);
        end;
      except
      end;

      // Garantia: se o XML não contiver o grupo <detPag>, injeta a partir do JSON e recarrega
      try
        var PaysJson := JsonGetArr(J, 'pagamentos');
        if (PreXMLPath <> '') and FileExists(PreXMLPath) then
        begin
          var tPagStr := '01';
          var vPagVal := 0.0;
          if Assigned(PaysJson) and (PaysJson.Count > 0) then
          begin
            var PayFirst := PaysJson.Items[0] as TJSONObject;
            tPagStr := JsonGetStr(PayFirst, 'tPag', '01');
            vPagVal := StrToFloatDef(JsonGetStr(PayFirst, 'valor', '0'), 0.0);
          end;
          var XMLText := TFile.ReadAllText(PreXMLPath, TEncoding.UTF8);
          if (Pos('<detPag>', XMLText) = 0) then
          begin
            var FS := TFormatSettings.Create;
            FS.DecimalSeparator := '.';
            // Se não vier valor do JSON, tenta usar vNF do XML como valor pago
            if (vPagVal <= 0) then
            begin
              var p1 := Pos('<vNF>', XMLText); var p2 := Pos('</vNF>', XMLText);
              if (p1 > 0) and (p2 > p1) then
              begin
                var vNFStr := Copy(XMLText, p1+5, p2 - (p1+5));
                vNFStr := StringReplace(vNFStr, ',', '.', [rfReplaceAll]);
                vPagVal := StrToFloatDef(vNFStr, 0.0);
              end;
              if (vPagVal <= 0) then vPagVal := 0.01;
            end;
            var vPagStr := FormatFloat('0.00', vPagVal, FS);
            var Det := '<detPag><tPag>' + tPagStr + '</tPag><vPag>' + vPagStr + '</vPag></detPag>';
            // Se já existir <pag>, insere o detPag dentro dele; caso contrário, cria o bloco <pag>
            if Pos('<pag/>', XMLText) > 0 then
            begin
              XMLText := StringReplace(XMLText, '<pag/>', '<pag>' + Det + '</pag>', []);
            end
            else
            begin
              var pagStart := Pos('<pag>', XMLText);
              var pagEnd := Pos('</pag>', XMLText);
              if (pagStart > 0) and (pagEnd > pagStart) then
              begin
                // injeta antes do fechamento de </pag>
                XMLText := Copy(XMLText, 1, pagEnd-1) + Det + Copy(XMLText, pagEnd, MaxInt);
              end
              else
              begin
                // nenhum <pag> presente: cria bloco completo antes de </infNFe>
                var Inject := '<pag>' + Det + '</pag>';
                XMLText := StringReplace(XMLText, '</infNFe>', Inject + '</infNFe>', []);
              end;
            end;
            TFile.WriteAllText(PreXMLPath, XMLText, TEncoding.UTF8);
            // Copia também para C:\Users\g5poa\OneDrive\Documentos\xml\pre_envio_latest.xml
            try
              var AltDir2 := 'C:\\Users\\g5poa\\OneDrive\\Documentos\\xml\\';
              var AltPath2 := AltDir2 + 'pre_envio_latest.xml';
              if not DirectoryExists(AltDir2) then ForceDirectories(AltDir2);
              TFile.Copy(PreXMLPath, AltPath2, True);
            except
            end;
            // Recarrega no ACBr para envio
            ACBrNFe1.NotasFiscais.Clear;
            ACBrNFe1.NotasFiscais.LoadFromFile(PreXMLPath);
          end;
        end;
      except
      end;

      // Garantia: se destinatário não contribuinte e indFinal=0 ou ausente, forçar indFinal=1
      try
        if IsConsumidorFinal and (PreXMLPath <> '') and FileExists(PreXMLPath) then
        begin
          var XMLText3 := TFile.ReadAllText(PreXMLPath, TEncoding.UTF8);
          if Pos('<indFinal>0</indFinal>', XMLText3) > 0 then
          begin
            XMLText3 := StringReplace(XMLText3, '<indFinal>0</indFinal>', '<indFinal>1</indFinal>', [rfReplaceAll]);
            TFile.WriteAllText(PreXMLPath, XMLText3, TEncoding.UTF8);
            ACBrNFe1.NotasFiscais.Clear;
            ACBrNFe1.NotasFiscais.LoadFromFile(PreXMLPath);
          end
          else if Pos('<indFinal>', XMLText3) = 0 then
          begin
            XMLText3 := StringReplace(XMLText3, '</ide>', '<indFinal>1</indFinal></ide>', []);
            TFile.WriteAllText(PreXMLPath, XMLText3, TEncoding.UTF8);
            ACBrNFe1.NotasFiscais.Clear;
            ACBrNFe1.NotasFiscais.LoadFromFile(PreXMLPath);
          end;

          // Forçar coerência de desconto/total com pagamento: se vNF != soma de vPag, injeta vDesc e ajusta vNF
          try
          begin
            XMLText3 := TFile.ReadAllText(PreXMLPath, TEncoding.UTF8);
            var vNFStr := ''; var vPagStr := '';
            var p1 := Pos('<vNF>', XMLText3); var p2 := Pos('</vNF>', XMLText3);
            if (p1 > 0) and (p2 > p1) then vNFStr := Copy(XMLText3, p1+5, p2 - (p1+5));
            var q1 := Pos('<detPag>', XMLText3); var q2 := Pos('</detPag>', XMLText3);
            if (q1 > 0) and (q2 > q1) then
            begin
              var sub := Copy(XMLText3, q1, q2 - q1);
              var t1 := Pos('<vPag>', sub); var t2 := Pos('</vPag>', sub);
              if (t1 > 0) and (t2 > t1) then vPagStr := Copy(sub, t1+6, t2 - (t1+6));
            end;
            var vNFVal := StrToFloatDef(StringReplace(vNFStr, ',', '.', [rfReplaceAll]), 0);
            var vPagVal := StrToFloatDef(StringReplace(vPagStr, ',', '.', [rfReplaceAll]), 0);
            if (vNFVal > 0) and (vPagVal > 0) and (Abs(vNFVal - vPagVal) > 0.001) then
            begin
              var vDescVal := vNFVal - vPagVal;
              if vDescVal > 0 then
              begin
                // injeta ou atualiza <vDesc> dentro de <ICMSTot>
                if Pos('<vDesc>', XMLText3) > 0 then
                begin
                  var d1 := Pos('<vDesc>', XMLText3); var d2 := Pos('</vDesc>', XMLText3);
                  if (d1 > 0) and (d2 > d1) then
                    XMLText3 := Copy(XMLText3, 1, d1+6) + StringReplace(FormatFloat('0.00', vDescVal), ',', '.', [rfReplaceAll]) + Copy(XMLText3, d2, MaxInt);
                end
                else
                begin
                  var totIdx := Pos('</ICMSTot>', XMLText3);
                  if totIdx > 0 then
                    XMLText3 := Copy(XMLText3, 1, totIdx) + '<vDesc>' + StringReplace(FormatFloat('0.00', vDescVal), ',', '.', [rfReplaceAll]) + '</vDesc>' + Copy(XMLText3, totIdx+10, MaxInt);
                end;
                // corrige <vNF>
                if (p1 > 0) and (p2 > p1) then
                  XMLText3 := Copy(XMLText3, 1, p1+4) + StringReplace(FormatFloat('0.00', vPagVal), ',', '.', [rfReplaceAll]) + Copy(XMLText3, p2, MaxInt);
                TFile.WriteAllText(PreXMLPath, XMLText3, TEncoding.UTF8);
                ACBrNFe1.NotasFiscais.Clear;
                ACBrNFe1.NotasFiscais.LoadFromFile(PreXMLPath);
              end;
            end;
          end; except end;
        end;
      except
      end;

      // Forçar coerência: se total pago (soma de <vPag>) divergir de vNF, injetar/ajustar vDesc e corrigir vNF
      try
        if (PreXMLPath <> '') and FileExists(PreXMLPath) then
        begin
          var XMLFix := TFile.ReadAllText(PreXMLPath, TEncoding.UTF8);
          // Se arquivo estiver vazio ou não conter <infNFe>, recarrega do ACBr e salva novamente para garantir conteúdo
          if (Trim(XMLFix) = '') or (Pos('<infNFe', XMLFix) = 0) then
          begin
            try
              if ACBrNFe1.NotasFiscais.Count > 0 then
              begin
                XMLFix := ACBrNFe1.NotasFiscais.Items[0].XML;
                TFile.WriteAllText(PreXMLPath, XMLFix, TEncoding.UTF8);
              end;
            except end;
          end;
          // Extrai vNF
          var vNFStr := '';
          var p1 := Pos('<vNF>', XMLFix); var p2 := Pos('</vNF>', XMLFix);
          if (p1 > 0) and (p2 > p1) then vNFStr := Copy(XMLFix, p1+5, p2 - (p1+5));
          var vNFVal := StrToFloatDef(StringReplace(vNFStr, ',', '.', [rfReplaceAll]), 0);
          // Soma vPag (pode haver múltiplos detPag)
          var vPagTotal := 0.0;
          var searchPos := 1;
          while True do
          begin
            var rest := Copy(XMLFix, searchPos, MaxInt);
            var rel := Pos('<vPag>', rest);
            if rel = 0 then Break;
            var s1 := searchPos + rel - 1;
            var rest2 := Copy(XMLFix, s1, MaxInt);
            var rel2 := Pos('</vPag>', rest2);
            if rel2 = 0 then Break;
            var s2 := s1 + rel2 - 1;
            var valStr := Copy(XMLFix, s1+6, s2 - (s1+6));
            vPagTotal := vPagTotal + StrToFloatDef(StringReplace(valStr, ',', '.', [rfReplaceAll]), 0);
            searchPos := s2 + 6;
          end;
          // Log sempre (sonda): registra valores extraídos mesmo sem divergência
          try
          begin
            var LogDirProbe := ExtractFilePath(Application.ExeName) + 'logs\\requests\\';
            try ForceDirectories(LogDirProbe); except end;
            var LogPathProbe := LogDirProbe + 'nf_totals_probe_' + FormatDateTime('yyyymmdd_hhnnss_zzz', Now) + '.log';
            var MsgProbe := 'PreXMLPath=' + PreXMLPath + ' vNF=' + FloatToStr(vNFVal) + ' vPagTotal=' + FloatToStr(vPagTotal);
            TFile.AppendAllText(LogPathProbe, MsgProbe + sLineBreak, TEncoding.UTF8);
          end; except end;
          if (vNFVal > 0) and (vPagTotal > 0) and (Abs(vNFVal - vPagTotal) > 0.001) then
          begin
            var vDescNeeded := vNFVal - vPagTotal;
            if vDescNeeded > 0 then
            begin
              // Log diagnóstico
              try
              begin
                var LogDir := ExtractFilePath(Application.ExeName) + 'logs\requests\';
                try ForceDirectories(LogDir); except end;
                var LogPath := LogDir + 'nf_totals_fix_' + FormatDateTime('yyyymmdd_hhnnss_zzz', Now) + '.log';
                var Msg := 'Ajuste vDesc/vNF: vNF=' + FloatToStr(vNFVal) + ' vPagTotal=' + FloatToStr(vPagTotal) + ' vDescNeeded=' + FloatToStr(vDescNeeded);
                TFile.AppendAllText(LogPath, Msg + sLineBreak, TEncoding.UTF8);
              end; except end;
              // Atualiza ou insere <vDesc> em <ICMSTot>
              var d1 := Pos('<vDesc>', XMLFix); var d2 := Pos('</vDesc>', XMLFix);
              if (d1 > 0) and (d2 > d1) then
              begin
                // Soma ao vDesc existente
                var curDescStr := Copy(XMLFix, d1+7, d2 - (d1+7));
                var curDesc := StrToFloatDef(StringReplace(curDescStr, ',', '.', [rfReplaceAll]), 0);
                var newDesc := curDesc + vDescNeeded;
                var newDescStr := StringReplace(FormatFloat('0.00', newDesc), ',', '.', [rfReplaceAll]);
                XMLFix := Copy(XMLFix, 1, d1+6) + newDescStr + Copy(XMLFix, d2, MaxInt);
              end
              else
              begin
                var totIdx := Pos('</ICMSTot>', XMLFix);
                if totIdx > 0 then
                  XMLFix := Copy(XMLFix, 1, totIdx) + '<vDesc>' + StringReplace(FormatFloat('0.00', vDescNeeded), ',', '.', [rfReplaceAll]) + '</vDesc>' + Copy(XMLFix, totIdx+10, MaxInt);
              end;
              // Corrige vNF para igualar o total pago
              if (p1 > 0) and (p2 > p1) then
                XMLFix := Copy(XMLFix, 1, p1+4) + StringReplace(FormatFloat('0.00', vPagTotal), ',', '.', [rfReplaceAll]) + Copy(XMLFix, p2, MaxInt);
              TFile.WriteAllText(PreXMLPath, XMLFix, TEncoding.UTF8);
              ACBrNFe1.NotasFiscais.Clear;
              ACBrNFe1.NotasFiscais.LoadFromFile(PreXMLPath);
            end;
          end;
        end;
      except
      end;

      // IBSCBS: desativado — não injetar este grupo para NF-e 4.00
      try
        // intentionally no-op
      except
      end;

      // Assinar, validar e enviar
      try
        // Ajuste definitivo via objeto ACBr: vNF/vDesc coerentes com soma dos pagamentos
        try
          if ACBrNFe1.NotasFiscais.Count > 0 then
          begin
            with ACBrNFe1.NotasFiscais.Items[0].NFe do
            begin
              var paySum: Double := 0.0;
              var idxPay: Integer;
              for idxPay := 0 to pag.Count - 1 do
              begin
                try paySum := paySum + pag.Items[idxPay].vPag; except end;
              end;
              var curVNF := 0.0;
              try curVNF := Total.ICMSTot.vNF; except end;
              if (paySum > 0) and (curVNF > 0) and (Abs(curVNF - paySum) > 0.001) then
              begin
                var needDesc := curVNF - paySum;
                if needDesc > 0 then
                begin
                  try Total.ICMSTot.vDesc := Total.ICMSTot.vDesc + needDesc; except end;
                  try Total.ICMSTot.vNF := paySum; except end;
                end;
              end;
            end;
          end;
        except
        end;
        // Recalcula tributos item->total e reconcilia vNF/vPag diretamente no objeto ACBr
        try
          if ACBrNFe1.NotasFiscais.Count > 0 then
          begin
            with ACBrNFe1.NotasFiscais.Items[0].NFe do
            begin
              var totalVProd := 0.0;
              var totalVDesc := 0.0;
              var totalBC := 0.0;
              var totalICMS := 0.0;
              var totalPIS := 0.0;
              var totalCOFINS := 0.0;
              var idx := 0;
              for idx := 0 to Det.Count - 1 do
              begin
                var vProdIt := 0.0; var vDescIt := 0.0; var baseNet := 0.0;
                try vProdIt := Det[idx].Prod.vProd; except end;
                try vDescIt := Det[idx].Prod.vDesc; except end;
                baseNet := vProdIt - vDescIt; if baseNet < 0 then baseNet := 0;
                // ICMS
                try
                  Det[idx].Imposto.ICMS.vBC := baseNet;
                  var pIcmsVal := 0.0; try pIcmsVal := Det[idx].Imposto.ICMS.pICMS; except pIcmsVal := 0.0; end;
                  if pIcmsVal <= 0 then pIcmsVal := 18.0;
                  Det[idx].Imposto.ICMS.pICMS := pIcmsVal;
                  Det[idx].Imposto.ICMS.vICMS := Round2(baseNet * (pIcmsVal / 100.0));
                except end;
                // PIS
                try
                  Det[idx].Imposto.PIS.vBC := baseNet;
                  var pPisVal := 0.0; try pPisVal := Det[idx].Imposto.PIS.pPIS; except pPisVal := 0.0; end;
                  if pPisVal <= 0 then pPisVal := 1.65;
                  Det[idx].Imposto.PIS.pPIS := pPisVal;
                  Det[idx].Imposto.PIS.vPIS := Round2(baseNet * (pPisVal / 100.0));
                except end;
                // COFINS
                try
                  Det[idx].Imposto.COFINS.vBC := baseNet;
                  var pCofVal := 0.0; try pCofVal := Det[idx].Imposto.COFINS.pCOFINS; except pCofVal := 0.0; end;
                  if pCofVal <= 0 then pCofVal := 7.60;
                  Det[idx].Imposto.COFINS.pCOFINS := pCofVal;
                  Det[idx].Imposto.COFINS.vCOFINS := Round2(baseNet * (pCofVal / 100.0));
                except end;
                // somatórios
                totalVProd := totalVProd + vProdIt;
                totalVDesc := totalVDesc + vDescIt;
                try totalBC := totalBC + Det[idx].Imposto.ICMS.vBC; except end;
                try totalICMS := totalICMS + Det[idx].Imposto.ICMS.vICMS; except end;
                try totalPIS := totalPIS + Det[idx].Imposto.PIS.vPIS; except end;
                try totalCOFINS := totalCOFINS + Det[idx].Imposto.COFINS.vCOFINS; except end;
              end;
              // Totais
              try
                Total.ICMSTot.vProd := totalVProd;
                Total.ICMSTot.vDesc := totalVDesc;
                Total.ICMSTot.vBC := Round2(totalBC);
                Total.ICMSTot.vICMS := Round2(totalICMS);
                Total.ICMSTot.vPIS := Round2(totalPIS);
                Total.ICMSTot.vCOFINS := Round2(totalCOFINS);
                var vFre := 0.0; var vSeg := 0.0; var vOut := 0.0;
                try vFre := Total.ICMSTot.vFrete; except end;
                try vSeg := Total.ICMSTot.vSeg; except end;
                try vOut := Total.ICMSTot.vOutro; except end;
                Total.ICMSTot.vNF := Round2(totalVProd - totalVDesc + vFre + vSeg + vOut);
              except end;
              // Reconciliar pagamento
              var paySum := 0.0; var k := 0;
              for k := 0 to pag.Count - 1 do
                try paySum := paySum + pag.Items[k].vPag; except end;
              if (paySum > 0) and (Abs(Total.ICMSTot.vNF - paySum) > 0.01) then
              begin
                var diff := Total.ICMSTot.vNF - paySum;
                if diff > 0 then
                begin
                  try Total.ICMSTot.vDesc := Round2(Total.ICMSTot.vDesc + diff); except end;
                end;
                try Total.ICMSTot.vNF := Round2(paySum); except end;
              end;
              // Ajustes ide
              try
                // Algumas versões do ACBr não expõem dhEmi; ajustamos flags compatíveis
                if IsConsumidorFinal then
                begin
                  // Ajusta usando inteiros compatíveis (1 = consumidor final; 1 = presencial)
                  try Ide.indFinal := 1; except end;
                  try Ide.indPres := 1; except end;
                end;
              except end;
            end;
          end;
        except
        end;
        // Sonda final do XML em memória, injeta detPag se necessário e SEMPRE persiste em pre_envio_final_*.xml
        try
          if ACBrNFe1.NotasFiscais.Count > 0 then
          begin
            var XmlMem := ACBrNFe1.NotasFiscais.Items[0].XML;
            var needDet := (Pos('<detPag>', XmlMem) = 0);
            if needDet then
            begin
              // tenta extrair vNF para usar como vPag
              var vNFStr := '';
              var p1 := Pos('<vNF>', XmlMem); var p2 := Pos('</vNF>', XmlMem);
              if (p1 > 0) and (p2 > p1) then vNFStr := Copy(XmlMem, p1+5, p2 - (p1+5));
              vNFStr := StringReplace(vNFStr, ',', '.', [rfReplaceAll]);
              var vPay := StrToFloatDef(vNFStr, 0.01);
              if vPay <= 0 then vPay := 0.01;
              var FS := TFormatSettings.Create; FS.DecimalSeparator := '.';
              var Det := '<detPag><tPag>01</tPag><vPag>' + FormatFloat('0.00', vPay, FS) + '</vPag></detPag>';
              if Pos('<pag/>', XmlMem) > 0 then
                XmlMem := StringReplace(XmlMem, '<pag/>', '<pag>' + Det + '</pag>', [])
              else
              begin
                var pagStart := Pos('<pag>', XmlMem);
                var pagEnd := Pos('</pag>', XmlMem);
                if (pagStart > 0) and (pagEnd > pagStart) then
                  XmlMem := Copy(XmlMem, 1, pagEnd-1) + Det + Copy(XmlMem, pagEnd, MaxInt)
                else
                  XmlMem := StringReplace(XmlMem, '</infNFe>', '<pag>' + Det + '</pag></infNFe>', []);
              end;
            end;
            // Ajuste final: higieniza campos, alinha descontos/pagamentos e atualiza tributos
            try
            begin
              // 0) Higieniza <xCpl>null</xCpl> e força indPres=1 se vier 0
              XmlMem := StringReplace(XmlMem, '<xCpl>null</xCpl>', '<xCpl></xCpl>', [rfReplaceAll]);
              XmlMem := StringReplace(XmlMem, '<xCpl>NULL</xCpl>', '<xCpl></xCpl>', [rfReplaceAll]);
              XmlMem := StringReplace(XmlMem, '<xCpl>Null</xCpl>', '<xCpl></xCpl>', [rfReplaceAll]);
              XmlMem := StringReplace(XmlMem, '<indPres>0</indPres>', '<indPres>1</indPres>', [rfReplaceAll]);
              // 0.1) Atualiza dhEmi para o horário atual (timezone fixo -03:00)
              var tz := '-03:00';
              var dt := FormatDateTime('yyyy-mm-dd"T"hh:nn:ss', Now) + tz;
              if Pos('<dhEmi>', XmlMem) > 0 then
              begin
                var pDE1 := Pos('<dhEmi>', XmlMem);
                var pDE2 := Pos('</dhEmi>', XmlMem);
                if (pDE1 > 0) and (pDE2 > pDE1) then
                begin
                  var prefix := Copy(XmlMem, 1, pDE1 + Length('<dhEmi>') - 1);
                  var suffix := Copy(XmlMem, pDE2, MaxInt);
                  XmlMem := prefix + dt + suffix;
                end;
              end
              else
              begin
                if Pos('</ide>', XmlMem) > 0 then
                  XmlMem := StringReplace(XmlMem, '</ide>', '<dhEmi>' + dt + '</dhEmi></ide>', []);
              end;

              // 1) Coleta vNF atual e soma de <vPag>
              var vNFStr := '';
              var vnfPos1, vnfPos2: Integer;
              vnfPos1 := Pos('<vNF>', XmlMem); vnfPos2 := Pos('</vNF>', XmlMem);
              if (vnfPos1 > 0) and (vnfPos2 > vnfPos1) then vNFStr := Copy(XmlMem, vnfPos1+5, vnfPos2 - (vnfPos1+5));
              var vNFVal := StrToFloatDef(StringReplace(vNFStr, ',', '.', [rfReplaceAll]), 0);
              var vPagTotal := 0.0;
              var findPos := 1;
              while True do
              begin
                var rest := Copy(XmlMem, findPos, MaxInt);
                var rp := Pos('<vPag>', rest);
                if rp = 0 then Break;
                var absStart := findPos + rp - 1;
                var rest2 := Copy(XmlMem, absStart, MaxInt);
                var rp2 := Pos('</vPag>', rest2);
                if rp2 = 0 then Break;
                var absEnd := absStart + rp2 - 1;
                var valStr := Copy(XmlMem, absStart+6, absEnd - (absStart+6));
                vPagTotal := vPagTotal + StrToFloatDef(StringReplace(valStr, ',', '.', [rfReplaceAll]), 0);
                findPos := absEnd + 6;
              end;
              // 2) Se vNF != soma(vPag), empurra o delta para o desconto DO ITEM (primeiro item)
              var deltaDesc := 0.0;
              if (vNFVal > 0) and (vPagTotal > 0) and (Abs(vNFVal - vPagTotal) > 0.001) then
                deltaDesc := vNFVal - vPagTotal;
              if deltaDesc < 0 then deltaDesc := 0;

              if deltaDesc > 0 then
              begin
                // localiza primeiro <det> e aumenta/injeta <vDesc>
                var detFirstRel := Pos('<det ', XmlMem);
                if detFirstRel > 0 then
                begin
                  var detFirstEndRel := Pos('</det>', Copy(XmlMem, detFirstRel, MaxInt));
                  if detFirstEndRel > 0 then
                  begin
                    var detFirstEnd := detFirstRel + detFirstEndRel - 1 + Length('</det>');
                    var detFirst := Copy(XmlMem, detFirstRel, detFirstEnd - detFirstRel);
                    var id1 := Pos('<vDesc>', detFirst); var id2 := Pos('</vDesc>', detFirst);
                    var FSLoc := TFormatSettings.Create; FSLoc.DecimalSeparator := '.';
                    if (id1 > 0) and (id2 > id1) then
                    begin
                      var curStr := Copy(detFirst, id1+7, id2 - (id1+7));
                      var curVal := StrToFloatDef(StringReplace(curStr, ',', '.', [rfReplaceAll]), 0);
                      var newVal := curVal + deltaDesc;
                      var newStr := StringReplace(FormatFloat('0.00', newVal, FSLoc), ',', '.', [rfReplaceAll]);
                      detFirst := Copy(detFirst, 1, id1+6) + newStr + Copy(detFirst, id2, MaxInt);
                    end
                    else
                    begin
                      var prodEnd := Pos('</prod>', detFirst);
                      if prodEnd > 0 then
                        detFirst := Copy(detFirst, 1, prodEnd-1) + '<vDesc>' + StringReplace(FormatFloat('0.00', deltaDesc, FSLoc), ',', '.', [rfReplaceAll]) + '</vDesc>' + Copy(detFirst, prodEnd, MaxInt);
                    end;
                    // reescreve bloco do primeiro det no XmlMem
                    XmlMem := Copy(XmlMem, 1, detFirstRel-1) + detFirst + Copy(XmlMem, detFirstEnd, MaxInt);
                  end;
                end;
              end;

              // 3) vDesc total = soma dos vDesc dos itens e 4) vNF = soma dos pagamentos, restrito ao bloco <ICMSTot>
              var sumDesc := 0.0;
              // somar apenas vDesc de itens (<det>), não o do total
              var scanPos := 1;
              while True do
              begin
                var detRel := Pos('<det ', Copy(XmlMem, scanPos, MaxInt));
                if detRel = 0 then Break;
                var detAbs := scanPos + detRel - 1;
                var detEndRel := Pos('</det>', Copy(XmlMem, detAbs, MaxInt));
                if detEndRel = 0 then Break;
                var detAbsEnd := detAbs + detEndRel - 1 + Length('</det>');
                var detTxt := Copy(XmlMem, detAbs, detAbsEnd - detAbs);
                var dv1 := Pos('<vDesc>', detTxt); var dv2 := Pos('</vDesc>', detTxt);
                if (dv1 > 0) and (dv2 > dv1) then
                begin
                  var dVal := Copy(detTxt, dv1+7, dv2 - (dv1+7));
                  sumDesc := sumDesc + StrToFloatDef(StringReplace(dVal, ',', '.', [rfReplaceAll]), 0);
                end;
                scanPos := detAbsEnd + 1;
              end;
              var FSNum := TFormatSettings.Create; FSNum.DecimalSeparator := '.';
              var sumDescStr := StringReplace(FormatFloat('0.00', sumDesc, FSNum), ',', '.', [rfReplaceAll]);
              // Localiza o bloco <ICMSTot>
              var totStart := Pos('<ICMSTot>', XmlMem);
              if totStart > 0 then
              begin
                var totEndRel := Pos('</ICMSTot>', Copy(XmlMem, totStart, MaxInt));
                if totEndRel > 0 then
                begin
                  var totEnd := totStart + totEndRel - 1 + Length('</ICMSTot>');
                  var totBlock := Copy(XmlMem, totStart, totEnd - totStart);
                  // se não encontramos descontos nos itens, usa diferença entre (vProd+frete+seg+outros) e vNF (pagamentos)
                  var readNumPre := function(const tagName: string): Double
                    var openTag, closeTag: string; var pA, pB: Integer; var sVal: string;
                  begin
                    openTag := '<' + tagName + '>';
                    closeTag := '</' + tagName + '>';
                    pA := Pos(openTag, totBlock); pB := Pos(closeTag, totBlock);
                    if (pA > 0) and (pB > pA) then
                    begin
                      sVal := Copy(totBlock, pA + Length(openTag), pB - (pA + Length(openTag)));
                      Exit(StrToFloatDef(StringReplace(sVal, ',', '.', [rfReplaceAll]), 0, FSNum));
                    end;
                    Exit(0);
                  end;
                  if (sumDesc <= 0) and (vPagTotal > 0) then
                  begin
                    var vProdTotPre := readNumPre('vProd');
                    var vFreteTotPre := readNumPre('vFrete');
                    var vSegTotPre := readNumPre('vSeg');
                    var vOutTotPre := readNumPre('vOutro');
                    var calcDesc := vProdTotPre + vFreteTotPre + vSegTotPre + vOutTotPre - vPagTotal;
                    if calcDesc < 0 then calcDesc := 0;
                    sumDesc := calcDesc;
                    sumDescStr := StringReplace(FormatFloat('0.00', sumDesc, FSNum), ',', '.', [rfReplaceAll]);
                  end;
                  // atualiza/injeta vDesc dentro de ICMSTot
                  var tD1 := Pos('<vDesc>', totBlock); var tD2 := Pos('</vDesc>', totBlock);
                  if (tD1 > 0) and (tD2 > tD1) then
                    totBlock := Copy(totBlock, 1, tD1+6) + sumDescStr + Copy(totBlock, tD2, MaxInt)
                  else
                  begin
                    var tClose := Pos('</ICMSTot>', totBlock);
                    if tClose > 0 then
                      totBlock := Copy(totBlock, 1, tClose-1) + '<vDesc>' + sumDescStr + '</vDesc>' + Copy(totBlock, tClose, MaxInt);
                  end;
                  // vNF: prioriza soma dos pagamentos; se não houver, usa (vProd - vDesc_total + frete + seguro + outros)
                  var vNFStrNew := StringReplace(FormatFloat('0.00', vPagTotal, FSNum), ',', '.', [rfReplaceAll]);
                  if (vPagTotal <= 0) then
                  begin
                    // fallback pelo somatório
                    var readNum := function(const tagName: string): Double
                      var openTag, closeTag: string; var pA, pB: Integer; var sVal: string;
                    begin
                      openTag := '<' + tagName + '>';
                      closeTag := '</' + tagName + '>';
                      pA := Pos(openTag, totBlock); pB := Pos(closeTag, totBlock);
                      if (pA > 0) and (pB > pA) then
                      begin
                        sVal := Copy(totBlock, pA + Length(openTag), pB - (pA + Length(openTag)));
                        Exit(StrToFloatDef(StringReplace(sVal, ',', '.', [rfReplaceAll]), 0, FSNum));
                      end;
                      Exit(0);
                    end;
                    var vProdTot := readNum('vProd');
                    var vFreteTot := readNum('vFrete');
                    var vSegTot := readNum('vSeg');
                    var vOutTot := readNum('vOutro');
                    var vNFCalc := vProdTot - StrToFloatDef(sumDescStr, 0, FSNum) + vFreteTot + vSegTot + vOutTot;
                    if vNFCalc < 0 then vNFCalc := 0;
                    vNFStrNew := StringReplace(FormatFloat('0.00', vNFCalc, FSNum), ',', '.', [rfReplaceAll]);
                  end;
                  var tN1 := Pos('<vNF>', totBlock); var tN2 := Pos('</vNF>', totBlock);
                  if (tN1 > 0) and (tN2 > tN1) then
                    totBlock := Copy(totBlock, 1, tN1+4) + vNFStrNew + Copy(totBlock, tN2, MaxInt);

                  // Sincroniza ICMS do primeiro item com os totais (vBC/vICMS) e garante vDesc/vNF nos totais
                  var totBC1 := Pos('<vBC>', totBlock); var totBC2 := Pos('</vBC>', totBlock);
                  var totIC1 := Pos('<vICMS>', totBlock); var totIC2 := Pos('</vICMS>', totBlock);
                  var totBCStr := ''; var totICMSStr := '';
                  if (totBC1 > 0) and (totBC2 > totBC1) then totBCStr := Copy(totBlock, totBC1+4, totBC2 - (totBC1+4));
                  if (totIC1 > 0) and (totIC2 > totIC1) then totICMSStr := Copy(totBlock, totIC1+7, totIC2 - (totIC1+7));
                  if (totBCStr <> '') and (totICMSStr <> '') then
                  begin
                    var detRel := Pos('<det ', XmlMem);
                    if detRel > 0 then
                    begin
                      var detEndRel := Pos('</det>', Copy(XmlMem, detRel, MaxInt));
                      if detEndRel > 0 then
                      begin
                        var detEnd := detRel + detEndRel - 1 + Length('</det>');
                        var detTxt := Copy(XmlMem, detRel, detEnd - detRel);
                        var icS := Pos('<ICMS00>', detTxt); var icE := Pos('</ICMS00>', detTxt);
                        if (icS > 0) and (icE > icS) then
                        begin
                          var icBlk := Copy(detTxt, icS, icE - icS + Length('</ICMS00>'));
                          var b1 := Pos('<vBC>', icBlk); var b2 := Pos('</vBC>', icBlk);
                          if (b1 > 0) and (b2 > b1) then icBlk := Copy(icBlk, 1, b1+4) + totBCStr + Copy(icBlk, b2, MaxInt);
                          var p1i := Pos('<pICMS>', icBlk); var p2i := Pos('</pICMS>', icBlk);
                          if (p1i > 0) and (p2i > p1i) then icBlk := Copy(icBlk, 1, p1i+6) + '18.00' + Copy(icBlk, p2i, MaxInt);
                          var v1 := Pos('<vICMS>', icBlk); var v2 := Pos('</vICMS>', icBlk);
                          if (v1 > 0) and (v2 > v1) then icBlk := Copy(icBlk, 1, v1+6) + totICMSStr + Copy(icBlk, v2, MaxInt);
                          detTxt := Copy(detTxt, 1, icS-1) + icBlk + Copy(detTxt, icE + Length('</ICMS00>'), MaxInt);
                          XmlMem := Copy(XmlMem, 1, detRel-1) + detTxt + Copy(XmlMem, detEnd, MaxInt);
                        end;
                      end;
                    end;
                  end;

                  // reaplica bloco ICMSTot ao XmlMem
                  XmlMem := Copy(XmlMem, 1, totStart-1) + totBlock + Copy(XmlMem, totEnd, MaxInt);
                end;
              end;

              // 5) Atualiza tributos padrão por item com base no valor líquido do item
              var itemSearch := 1;
              while True do
              begin
                var detStartRel := Pos('<det ', Copy(XmlMem, itemSearch, MaxInt));
                if detStartRel = 0 then Break;
                var detStart := itemSearch + detStartRel - 1;
                var detEndRel := Pos('</det>', Copy(XmlMem, detStart, MaxInt));
                if detEndRel = 0 then Break;
                var detEnd := detStart + detEndRel - 1 + Length('</det>');
                var detBlock := Copy(XmlMem, detStart, detEnd - detStart);
                // Extrai vProd e vDesc do item
                var vProdStr: string := '0'; var vDescStr: string := '0';
                var vProdPos1, vProdPos2: Integer;
                vProdPos1 := Pos('<vProd>', detBlock); vProdPos2 := Pos('</vProd>', detBlock);
                if (vProdPos1 > 0) and (vProdPos2 > vProdPos1) then vProdStr := Copy(detBlock, vProdPos1+7, vProdPos2 - (vProdPos1+7));
                var vDescPos1, vDescPos2: Integer;
                vDescPos1 := Pos('<vDesc>', detBlock); vDescPos2 := Pos('</vDesc>', detBlock);
                if (vDescPos1 > 0) and (vDescPos2 > vDescPos1) then vDescStr := Copy(detBlock, vDescPos1+7, vDescPos2 - (vDescPos1+7));
                var vProdVal := StrToFloatDef(StringReplace(vProdStr, ',', '.', [rfReplaceAll]), 0);
                var vDescVal := StrToFloatDef(StringReplace(vDescStr, ',', '.', [rfReplaceAll]), 0);
                var baseNet := vProdVal - vDescVal;
                if baseNet < 0 then baseNet := 0;
                var baseStr := StringReplace(FormatFloat('0.00', baseNet), ',', '.', [rfReplaceAll]);
                // ICMS00
                var icStart := Pos('<ICMS00>', detBlock);
                if icStart > 0 then
                begin
                  var icEnd := Pos('</ICMS00>', detBlock);
                  if (icEnd > icStart) then
                  begin
                    var icBlock := Copy(detBlock, icStart, icEnd - icStart + Length('</ICMS00>'));
                    // vBC
                    var tb1 := Pos('<vBC>', icBlock); var tb2 := Pos('</vBC>', icBlock);
                    if (tb1 > 0) and (tb2 > tb1) then
                      icBlock := Copy(icBlock, 1, tb1+4) + baseStr + Copy(icBlock, tb2, MaxInt);
                    // pICMS 18.00
                    var tp1 := Pos('<pICMS>', icBlock); var tp2 := Pos('</pICMS>', icBlock);
                    if (tp1 > 0) and (tp2 > tp1) then
                      icBlock := Copy(icBlock, 1, tp1+6) + '18.00' + Copy(icBlock, tp2, MaxInt);
                    // vICMS base*0.18
                    var vICMSStr := StringReplace(FormatFloat('0.00', baseNet * 0.18), ',', '.', [rfReplaceAll]);
                    var tv1 := Pos('<vICMS>', icBlock); var tv2 := Pos('</vICMS>', icBlock);
                    if (tv1 > 0) and (tv2 > tv1) then
                      icBlock := Copy(icBlock, 1, tv1+6) + vICMSStr + Copy(icBlock, tv2, MaxInt);
                    // Recoloca no detBlock
                    detBlock := Copy(detBlock, 1, icStart-1) + icBlock + Copy(detBlock, icEnd + Length('</ICMS00>'), MaxInt);
                  end;
                end;
                // PIS
                var pisStart := Pos('<PISAliq>', detBlock);
                if pisStart > 0 then
                begin
                  var pisEnd := Pos('</PISAliq>', detBlock);
                  if (pisEnd > pisStart) then
                  begin
                    var pisBlock := Copy(detBlock, pisStart, pisEnd - pisStart + Length('</PISAliq>'));
                    var pb1 := Pos('<vBC>', pisBlock); var pb2 := Pos('</vBC>', pisBlock);
                    if (pb1 > 0) and (pb2 > pb1) then
                      pisBlock := Copy(pisBlock, 1, pb1+4) + baseStr + Copy(pisBlock, pb2, MaxInt);
                    var pPis1 := Pos('<pPIS>', pisBlock); var pPis2 := Pos('</pPIS>', pisBlock);
                    if (pPis1 > 0) and (pPis2 > pPis1) then
                      pisBlock := Copy(pisBlock, 1, pPis1+5) + '1.65' + Copy(pisBlock, pPis2, MaxInt);
                    var vPISStr := StringReplace(FormatFloat('0.00', baseNet * 0.0165), ',', '.', [rfReplaceAll]);
                    var pv1 := Pos('<vPIS>', pisBlock); var pv2 := Pos('</vPIS>', pisBlock);
                    if (pv1 > 0) and (pv2 > pv1) then
                      pisBlock := Copy(pisBlock, 1, pv1+5) + vPISStr + Copy(pisBlock, pv2, MaxInt);
                    detBlock := Copy(detBlock, 1, pisStart-1) + pisBlock + Copy(detBlock, pisEnd + Length('</PISAliq>'), MaxInt);
                  end;
                end;
                // COFINS
                var cofStart := Pos('<COFINSAliq>', detBlock);
                if cofStart > 0 then
                begin
                  var cofEnd := Pos('</COFINSAliq>', detBlock);
                  if (cofEnd > cofStart) then
                  begin
                    var cofBlock := Copy(detBlock, cofStart, cofEnd - cofStart + Length('</COFINSAliq>'));
                    var cb1 := Pos('<vBC>', cofBlock); var cb2 := Pos('</vBC>', cofBlock);
                    if (cb1 > 0) and (cb2 > cb1) then
                      cofBlock := Copy(cofBlock, 1, cb1+4) + baseStr + Copy(cofBlock, cb2, MaxInt);
                    var cp1 := Pos('<pCOFINS>', cofBlock); var cp2 := Pos('</pCOFINS>', cofBlock);
                    if (cp1 > 0) and (cp2 > cp1) then
                      cofBlock := Copy(cofBlock, 1, cp1+8) + '7.60' + Copy(cofBlock, cp2, MaxInt);
                    var vCOFINSStr := StringReplace(FormatFloat('0.00', baseNet * 0.076), ',', '.', [rfReplaceAll]);
                    var cv1 := Pos('<vCOFINS>', cofBlock); var cv2 := Pos('</vCOFINS>', cofBlock);
                    if (cv1 > 0) and (cv2 > cv1) then
                      cofBlock := Copy(cofBlock, 1, cv1+8) + vCOFINSStr + Copy(cofBlock, cv2, MaxInt);
                    detBlock := Copy(detBlock, 1, cofStart-1) + cofBlock + Copy(detBlock, cofEnd + Length('</COFINSAliq>'), MaxInt);
                  end;
                end;
                // Reaplica detBlock no XmlMem
                XmlMem := Copy(XmlMem, 1, detStart-1) + detBlock + Copy(XmlMem, detEnd, MaxInt);
                itemSearch := detStart + Length(detBlock);
              end;
            end; except end;

            // Remove IBSCBS e força coerência de itens e totais ANTES de persistir
            try
            begin
              // Remove blocos IBSCBS
              while True do
              begin
                var ibS := Pos('<IBSCBS', XmlMem);
                if ibS = 0 then Break;
                var afterS := Copy(XmlMem, ibS, MaxInt);
                var ibErel := Pos('</IBSCBS>', afterS);
                if ibErel = 0 then Break;
                var ibE := ibS + ibErel - 1 + Length('</IBSCBS>');
                XmlMem := Copy(XmlMem, 1, ibS-1) + Copy(XmlMem, ibE, MaxInt);
              end;
              // Recalcula impostos por item e coleta soma de descontos
              var sumDescIt := 0.0;
              var scanI := 1;
              while True do
              begin
                var dRel := Pos('<det ', Copy(XmlMem, scanI, MaxInt));
                if dRel = 0 then Break;
                var dAbs := scanI + dRel - 1;
                var dEndRel := Pos('</det>', Copy(XmlMem, dAbs, MaxInt));
                if dEndRel = 0 then Break;
                var dAbsEnd := dAbs + dEndRel - 1 + Length('</det>');
                var dTxt := Copy(XmlMem, dAbs, dAbsEnd - dAbs);
                var vp1 := Pos('<vProd>', dTxt); var vp2 := Pos('</vProd>', dTxt);
                var vd1 := Pos('<vDesc>', dTxt); var vd2 := Pos('</vDesc>', dTxt);
                var vProdV := 0.0; var vDescV := 0.0;
                if (vp1 > 0) and (vp2 > vp1) then vProdV := StrToFloatDef(StringReplace(Copy(dTxt, vp1+7, vp2 - (vp1+7)), ',', '.', [rfReplaceAll]), 0);
                if (vd1 > 0) and (vd2 > vd1) then vDescV := StrToFloatDef(StringReplace(Copy(dTxt, vd1+7, vd2 - (vd1+7)), ',', '.', [rfReplaceAll]), 0);
                sumDescIt := sumDescIt + vDescV;
                var baseNet := vProdV - vDescV; if baseNet < 0 then baseNet := 0;
                var baseStr := StringReplace(FormatFloat('0.00', baseNet), ',', '.', [rfReplaceAll]);
                // ICMS00
                var icS := Pos('<ICMS00>', dTxt); var icE := Pos('</ICMS00>', dTxt);
                if (icS > 0) and (icE > icS) then
                begin
                  var icBlk := Copy(dTxt, icS, icE - icS + Length('</ICMS00>'));
                  var tb1 := Pos('<vBC>', icBlk); var tb2 := Pos('</vBC>', icBlk);
                  if (tb1 > 0) and (tb2 > tb1) then icBlk := Copy(icBlk, 1, tb1+4) + baseStr + Copy(icBlk, tb2, MaxInt);
                  var tp1 := Pos('<pICMS>', icBlk); var tp2 := Pos('</pICMS>', icBlk);
                  if (tp1 > 0) and (tp2 > tp1) then icBlk := Copy(icBlk, 1, tp1+6) + '18.00' + Copy(icBlk, tp2, MaxInt);
                  var vIC := StringReplace(FormatFloat('0.00', baseNet * 0.18), ',', '.', [rfReplaceAll]);
                  var tv1 := Pos('<vICMS>', icBlk); var tv2 := Pos('</vICMS>', icBlk);
                  if (tv1 > 0) and (tv2 > tv1) then icBlk := Copy(icBlk, 1, tv1+6) + vIC + Copy(icBlk, tv2, MaxInt);
                  dTxt := Copy(dTxt, 1, icS-1) + icBlk + Copy(dTxt, icE + Length('</ICMS00>'), MaxInt);
                end;
                // PIS
                var pS := Pos('<PISAliq>', dTxt); var pE := Pos('</PISAliq>', dTxt);
                if (pS > 0) and (pE > pS) then
                begin
                  var pBlk := Copy(dTxt, pS, pE - pS + Length('</PISAliq>'));
                  var pb1 := Pos('<vBC>', pBlk); var pb2 := Pos('</vBC>', pBlk);
                  if (pb1 > 0) and (pb2 > pb1) then pBlk := Copy(pBlk, 1, pb1+4) + baseStr + Copy(pBlk, pb2, MaxInt);
                  var pp1 := Pos('<pPIS>', pBlk); var pp2 := Pos('</pPIS>', pBlk);
                  if (pp1 > 0) and (pp2 > pp1) then pBlk := Copy(pBlk, 1, pp1+5) + '1.65' + Copy(pBlk, pp2, MaxInt);
                  var vP := StringReplace(FormatFloat('0.00', baseNet * 0.0165), ',', '.', [rfReplaceAll]);
                  var pv1 := Pos('<vPIS>', pBlk); var pv2 := Pos('</vPIS>', pBlk);
                  if (pv1 > 0) and (pv2 > pv1) then pBlk := Copy(pBlk, 1, pv1+5) + vP + Copy(pBlk, pv2, MaxInt);
                  dTxt := Copy(dTxt, 1, pS-1) + pBlk + Copy(dTxt, pE + Length('</PISAliq>'), MaxInt);
                end;
                // COFINS
                var cS := Pos('<COFINSAliq>', dTxt); var cE := Pos('</COFINSAliq>', dTxt);
                if (cS > 0) and (cE > cS) then
                begin
                  var cBlk := Copy(dTxt, cS, cE - cS + Length('</COFINSAliq>'));
                  var cb1 := Pos('<vBC>', cBlk); var cb2 := Pos('</vBC>', cBlk);
                  if (cb1 > 0) and (cb2 > cb1) then cBlk := Copy(cBlk, 1, cb1+4) + baseStr + Copy(cBlk, cb2, MaxInt);
                  var cp1 := Pos('<pCOFINS>', cBlk); var cp2 := Pos('</pCOFINS>', cBlk);
                  if (cp1 > 0) and (cp2 > cp1) then cBlk := Copy(cBlk, 1, cp1+8) + '7.60' + Copy(cBlk, cp2, MaxInt);
                  var vC := StringReplace(FormatFloat('0.00', baseNet * 0.076), ',', '.', [rfReplaceAll]);
                  var cv1 := Pos('<vCOFINS>', cBlk); var cv2 := Pos('</vCOFINS>', cBlk);
                  if (cv1 > 0) and (cv2 > cv1) then cBlk := Copy(cBlk, 1, cv1+8) + vC + Copy(cBlk, cv2, MaxInt);
                  dTxt := Copy(dTxt, 1, cS-1) + cBlk + Copy(dTxt, cE + Length('</COFINSAliq>'), MaxInt);
                end;
                // aplica item atualizado
                XmlMem := Copy(XmlMem, 1, dAbs-1) + dTxt + Copy(XmlMem, dAbsEnd, MaxInt);
                scanI := dAbs + Length(dTxt) + 1;
              end;
              // Ajusta ICMSTot: vDesc = soma descontos itens; vNF = soma pagamentos (se houver)
              var sumDescStr2 := StringReplace(FormatFloat('0.00', sumDescIt), ',', '.', [rfReplaceAll]);
              var totS := Pos('<ICMSTot>', XmlMem);
              if totS > 0 then
              begin
                var totErel := Pos('</ICMSTot>', Copy(XmlMem, totS, MaxInt));
                if totErel > 0 then
                begin
                  var totE := totS + totErel - 1 + Length('</ICMSTot>');
                  var totTxt := Copy(XmlMem, totS, totE - totS);
                  var td1 := Pos('<vDesc>', totTxt); var td2 := Pos('</vDesc>', totTxt);
                  if (td1 > 0) and (td2 > td1) then totTxt := Copy(totTxt, 1, td1+6) + sumDescStr2 + Copy(totTxt, td2, MaxInt)
                  else
                  begin
                    var tClose := Pos('</ICMSTot>', totTxt);
                    if tClose > 0 then totTxt := Copy(totTxt, 1, tClose-1) + '<vDesc>' + sumDescStr2 + '</vDesc>' + Copy(totTxt, tClose, MaxInt);
                  end;
                  // vDesc já ajustado acima; agora vNF = soma de vPag (fallback pelo somatório se não houver pagamentos)
                  var paySum := 0.0; var fP := 1;
                  while True do
                  begin
                    var restP := Copy(XmlMem, fP, MaxInt);
                    var p1 := Pos('<vPag>', restP); if p1 = 0 then Break;
                    var a1 := fP + p1 - 1; var restP2 := Copy(XmlMem, a1, MaxInt);
                    var p2 := Pos('</vPag>', restP2); if p2 = 0 then Break;
                    var a2 := a1 + p2 - 1;
                    var pv := Copy(XmlMem, a1+6, a2 - (a1+6));
                    paySum := paySum + StrToFloatDef(StringReplace(pv, ',', '.', [rfReplaceAll]), 0);
                    fP := a2 + 6;
                  end;
                  var vNFNew := 0.0;
                  if paySum > 0 then vNFNew := paySum
                  else
                  begin
                    // fallback: vProd - vDesc_total + frete + seguro + outros
                    var readNum := function(const tagName: string): Double
                      var oT, cT: string; var pA, pB: Integer; var sVal: string;
                    begin
                      oT := '<' + tagName + '>'; cT := '</' + tagName + '>';
                      pA := Pos(oT, totTxt); pB := Pos(cT, totTxt);
                      if (pA > 0) and (pB > pA) then
                      begin
                        sVal := Copy(totTxt, pA + Length(oT), pB - (pA + Length(oT)));
                        Exit(StrToFloatDef(StringReplace(sVal, ',', '.', [rfReplaceAll]), 0));
                      end;
                      Exit(0);
                    end;
                    var vProdT := readNum('vProd');
                    var vFreteT := readNum('vFrete');
                    var vSegT := readNum('vSeg');
                    var vOutT := readNum('vOutro');
                    vNFNew := vProdT - StrToFloatDef(sumDescStr2, 0) + vFreteT + vSegT + vOutT;
                    if vNFNew < 0 then vNFNew := 0;
                  end;
                  var tn1 := Pos('<vNF>', totTxt); var tn2 := Pos('</vNF>', totTxt);
                  if (tn1 > 0) and (tn2 > tn1) then totTxt := Copy(totTxt, 1, tn1+4) + StringReplace(FormatFloat('0.00', vNFNew), ',', '.', [rfReplaceAll]) + Copy(totTxt, tn2, MaxInt);
                  XmlMem := Copy(XmlMem, 1, totS-1) + totTxt + Copy(XmlMem, totE, MaxInt);
                end;
              end;
            end; except end;

            // Persistência final simplificada: grava diretamente do objeto e sem recarregar
            var FinalXMLDir := ExtractFilePath(Application.ExeName) + 'logs\requests\';
            try ForceDirectories(FinalXMLDir); except end;
            var FinalXMLPath := FinalXMLDir + 'pre_envio_final_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
            ACBrNFe1.NotasFiscais.Items[0].GravarXML(FinalXMLPath);
            try Resp.AddPair('pre_xml_path_final', FinalXMLPath); except end;
            try Resp.AddPair('pre_xml_final_b64', FileToBase64(FinalXMLPath)); except end;
          end;
        except
        end;
        BuildPhase := 'enviar';
        // Se houver apenas 1 NFe no lote, força indicador de envio síncrono quando disponível
        // Envio síncrono para 1 NFe por lote (usando overload síncrono do ACBrNFe)
        if not ACBrNFe1.Enviar(1, False, True) then
          raise Exception.Create('Falha ao transmitir NFe');
      except
        on E: Exception do
        begin
          // Salva XML gerado (mesmo com falha) para diagnóstico
          try
            DebugXML := ExtractFilePath(Application.ExeName) + 'logs\\requests\\ultimanfe_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
            try ForceDirectories(ExtractFilePath(DebugXML)); except end;
            if ACBrNFe1.NotasFiscais.Count > 0 then
              ACBrNFe1.NotasFiscais.Items[0].GravarXML(DebugXML);
          except
          end;
          // Também retorna inline em base64
          try
            if DebugXML <> '' then
              Resp.AddPair('ultimanfe_b64', FileToBase64(DebugXML));
          except end;
          BuildPhase := 'enviar_error';
          raise;
        end;
      end;

      // Resultado
      Chave := ACBrNFe1.NotasFiscais.Items[0].NFe.infNFe.ID;
      Protocolo := ACBrNFe1.WebServices.Retorno.Protocolo;
      XMLPath := ACBrNFe1.NotasFiscais.Items[0].NomeArq;
      // Status/motivo da SEFAZ
      var RetCStat: Integer := 0;
      var RetXMotivo: string := '';
      var RetDhRecbto: string := '';
      try
        RetCStat := ACBrNFe1.WebServices.Retorno.cStat;
        RetXMotivo := ACBrNFe1.WebServices.Retorno.xMotivo;
      except end;
      // Fallback: se o retorno síncrono não preencheu, tenta extrair do XML (nfeProc/protNFe)
      if (RetCStat = 0) or (Protocolo = '') then
      begin
        try
          if (XMLPath <> '') and FileExists(XMLPath) then
          begin
            var XmlS := TFile.ReadAllText(XMLPath, TEncoding.UTF8);
            // Isola bloco <protNFe>...</protNFe>
            var p1 := Pos('<protNFe', XmlS);
            if p1 = 0 then p1 := Pos('<protNFe', UpperCase(XmlS));
            if p1 > 0 then
            begin
              var p2 := Pos('</protNFe>', XmlS);
              if (p2 > p1) then
              begin
                var Prot := Copy(XmlS, p1, p2 - p1 + Length('</protNFe>'));
                var cStatStr := TagVal(Prot, 'cStat');
                var xMotStr := TagVal(Prot, 'xMotivo');
                var nProtStr := TagVal(Prot, 'nProt');
                var dhRecStr := TagVal(Prot, 'dhRecbto');
                if cStatStr <> '' then
                begin
                  RetCStat := StrToIntDef(Trim(cStatStr), RetCStat);
                end;
                if xMotStr <> '' then RetXMotivo := xMotStr;
                if (Protocolo = '') and (nProtStr <> '') then Protocolo := nProtStr;
                if dhRecStr <> '' then RetDhRecbto := dhRecStr;
              end;
            end;
          end;
        except
        end;
      end;
      // Salva XML bruto de retorno do WebService (autorização) para auditoria
      try
        var RetWS := '';
        var RetPath := '';
        try RetWS := ACBrNFe1.WebServices.Retorno.RetWS; except end;
        if RetWS <> '' then
        begin
          var LogDir := ExtractFilePath(Application.ExeName) + 'logs\';
          if not DirectoryExists(LogDir) then ForceDirectories(LogDir);
          RetPath := LogDir + 'retorno_ws_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
          try
            var F: TextFile;
            AssignFile(F, RetPath);
            Rewrite(F);
            try Writeln(F, RetWS); finally CloseFile(F); end;
          except
            RetPath := '';
          end;
        end;
        if RetPath <> '' then
          Resp.AddPair('ret_ws_path', RetPath);
      except
      end;
      if GeneratePDF then
      begin
        try
          // Configura DANFE para padrão oficial (sem preview/status)
          // Propriedades de preview/status podem não existir em algumas versões do componente
          
          // Define caminho de saída do PDF
          var PDFDir := 'C:\\xampp\\htdocs\\Emissor\\qfiscal\\storage\\danfe\\';
          try ForceDirectories(PDFDir); except end;
          try ACBrNFeDANFeRL1.PathPDF := PDFDir; except end;
          
          // Estratégia agressiva para evitar WIC: configuração mínima
          try
            ACBrNFeDANFeRL1.Logo := '';
            ACBrNFeDANFeRL1.Sistema := '';
            ACBrNFeDANFeRL1.Impressora := '';
          except end;
          var PDFSuccess := False;
          try
            {$R-}
            ACBrNFe1.NotasFiscais.ImprimirPDF;
            {$R+}
            PDFSuccess := True;
          except
            try
              {$R-}
              ACBrNFe1.NotasFiscais.Items[0].ImprimirPDF;
              {$R+}
              PDFSuccess := True;
            except
              PDFSuccess := False;
            end;
          end;
          // Tenta localizar o PDF gerado
          try
            PDFPath := PDFDir + 'NFe_' + ACBrNFe1.NotasFiscais.Items[0].NFe.infNFe.ID + '.pdf';
            if not FileExists(PDFPath) then
            begin
              // Tentativas alternativas de nome
              var Alt1 := PDFDir + ACBrNFe1.NotasFiscais.Items[0].NFe.infNFe.ID + '.pdf';
              var Ch := ACBrNFe1.NotasFiscais.Items[0].NFe.infNFe.ID;
              var Alt2 := PDFDir + 'DANFE_' + Ch + '.pdf';
              if FileExists(Alt1) then PDFPath := Alt1
              else if FileExists(Alt2) then PDFPath := Alt2
              else
              begin
              // Evita PDF aleatório: seleciona apenas PDFs que contenham a chave
              var SR: TSearchRec;
              var LastTime: TDateTime := 0;
              var Best: string := '';
              var ChaveID := ACBrNFe1.NotasFiscais.Items[0].NFe.infNFe.ID;
              var RawChave := ChaveID;
              if (Length(RawChave) > 3) and SameText(Copy(RawChave,1,3),'NFe') then
                RawChave := Copy(RawChave,4,MaxInt);
              if FindFirst(PDFDir + '*.pdf', faAnyFile, SR) = 0 then
              begin
                repeat
                  var NameU := UpperCase(SR.Name);
                  var Match := (Pos(UpperCase(ChaveID), NameU) > 0)
                               or (Pos(UpperCase(RawChave), NameU) > 0)
                               or (Pos('NFE_' + UpperCase(ChaveID), NameU) > 0)
                               or (Pos('NFE_' + UpperCase(RawChave), NameU) > 0)
                               or (Pos('DANFE_' + UpperCase(ChaveID), NameU) > 0)
                               or (Pos('DANFE_' + UpperCase(RawChave), NameU) > 0);
                  if Match then
                  begin
                    var FTime := SR.TimeStamp;
                    if (Best = '') or (FTime > LastTime) then
                    begin
                      Best := IncludeTrailingPathDelimiter(PDFDir) + SR.Name;
                      LastTime := FTime;
                    end;
                  end;
                until FindNext(SR) <> 0;
                FindClose(SR);
              end;
              PDFPath := Best;
              end;
            end;
            if (PDFPath <> '') and not FileExists(PDFPath) then PDFPath := '';
          except
            PDFPath := '';
          end;
        except
          PDFPath := '';
        end;
      end
      else
      begin
        PDFPath := '';
      end;

      Resp.AddPair('ok', TJSONBool.Create(True));
      Resp.AddPair('chave', Chave);
      Resp.AddPair('protocolo', Protocolo);
      Resp.AddPair('xml_path', XMLPath);
      Resp.AddPair('cStat', TJSONNumber.Create(RetCStat));
      // Expor número e série efetivamente aplicados no XML (para auditoria/sincronização no ERP)
      try
        if (ACBrNFe1.NotasFiscais.Count > 0) then
        begin
          var IdeNum := ACBrNFe1.NotasFiscais.Items[0].NFe.Ide.nNF;
          var IdeSer := ACBrNFe1.NotasFiscais.Items[0].NFe.Ide.serie;
          Resp.AddPair('nNF', TJSONNumber.Create(IdeNum));
          Resp.AddPair('numero', TJSONNumber.Create(IdeNum));
          Resp.AddPair('serie', TJSONNumber.Create(IdeSer));
        end;
      except
      end;
      if RetXMotivo <> '' then Resp.AddPair('xMotivo', RetXMotivo);
      if RetDhRecbto <> '' then Resp.AddPair('dhRecbto', RetDhRecbto);
      if PDFPath <> '' then Resp.AddPair('pdf_path', PDFPath);
      if PreXMLPath <> '' then Resp.AddPair('pre_xml_path', PreXMLPath);
      Resp.AddPair('build_phase', BuildPhase);
      // Garantia extra: se ainda não anexou, tenta no final
      AttachPreXMLBase64;
    except
      on E: Exception do
      begin
        Resp.AddPair('ok', TJSONBool.Create(False));
        Resp.AddPair('error', E.Message);
        if PreXMLPath <> '' then Resp.AddPair('pre_xml_path', PreXMLPath);
        if BuildPhase <> '' then Resp.AddPair('build_phase', BuildPhase);
        // Tenta salvar XML mesmo em erro de montagem
        try
          var ErrXML := ExtractFilePath(Application.ExeName) + 'logs\\requests\\build_error_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
          if ACBrNFe1.NotasFiscais.Count > 0 then
          begin
            ACBrNFe1.NotasFiscais.Items[0].GravarXML(ErrXML);
            Resp.AddPair('build_xml_path', ErrXML);
            // E inline em base64
            try Resp.AddPair('build_xml_b64', FileToBase64(ErrXML)); except end;
          end;
        except end;
        // Adiciona detalhes de rejeição quando disponíveis
        try
          var RetCStat2 := ACBrNFe1.WebServices.Retorno.cStat;
          var RetXMotivo2 := ACBrNFe1.WebServices.Retorno.xMotivo;
          Resp.AddPair('cStat', TJSONNumber.Create(RetCStat2));
          if RetXMotivo2 <> '' then Resp.AddPair('xMotivo', RetXMotivo2);
          // Salva XML de retorno do webservice
          var RetWS := '';
          try RetWS := ACBrNFe1.WebServices.Retorno.RetWS; except end;
          if RetWS <> '' then
          begin
            var LogDir := ExtractFilePath(Application.ExeName) + 'logs\';
            if not DirectoryExists(LogDir) then ForceDirectories(LogDir);
            var RetPath := LogDir + 'retorno_ws_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xml';
            try
              var F: TextFile;
              AssignFile(F, RetPath);
              Rewrite(F);
              try Writeln(F, RetWS); finally CloseFile(F); end;
              Resp.AddPair('ret_ws_path', RetPath);
            except end;
          end;
        except end;
      end;
    end;
    Result := Resp.ToString;
  finally
    Resp.Free;
  end;
end;

function TForm1.GerarDanfeJSON(const JSONData: string): string;
var
  J, Conf: TJSONObject;
  Resp: TJSONObject;
  XMLPath, PDFDir, PDFPath: string;
  GeneratePDF: Boolean;
  PDFSuccess: Boolean;
  PdfErrorMsg: string;
  ComInitialized: Boolean;
  EnginePref: string;
  UseFPDF: Boolean;
  // Sanitização do XML para evitar ERangeError no RLNFe/Fortes
  function SanitizeText(const S: string): string;
  var i: Integer; ch: Char;
  begin
    Result := '';
    for i := 1 to Length(S) do
    begin
      ch := S[i];
      // mantém CR/LF e caracteres imprimíveis básicos
      if (ch = #13) or (ch = #10) or (Ord(ch) >= 32) then
        Result := Result + ch;
    end;
    // normaliza espaços
    Result := Trim(StringReplace(Result, '  ', ' ', [rfReplaceAll]));
  end;
  function TruncTo(const S: string; MaxLen: Integer): string;
  begin
    if (MaxLen > 0) and (Length(S) > MaxLen) then
      Result := Copy(S, 1, MaxLen)
    else
      Result := S;
  end;
  function ReplaceTagValueAll(const Xml, Tag: string; MaxLen: Integer): string;
  var
    openTag, closeTag: string;
    p1, p2, startVal: Integer;
    val, newVal: string;
    Work: string;
  begin
    Work := Xml;
    openTag := '<' + Tag + '>';
    closeTag := '</' + Tag + '>';
    p1 := Pos(openTag, Work);
    while p1 > 0 do
    begin
      startVal := p1 + Length(openTag);
      p2 := Pos(closeTag, Work);
      if (p2 > startVal) then
      begin
        val := Copy(Work, startVal, p2 - startVal);
        newVal := TruncTo(SanitizeText(val), MaxLen);
        if newVal <> val then
        begin
          Work := Copy(Work, 1, p1 - 1) + openTag + newVal + closeTag + Copy(Work, p2 + Length(closeTag), MaxInt);
        end
        else
        begin
          // avança após o fechamento para achar próximas ocorrências
          p1 := Pos(openTag, Copy(Work, p2 + Length(closeTag), MaxInt));
          if p1 > 0 then p1 := p1 + p2 + Length(closeTag);
          Continue;
        end;
      end
      else
        Break;
      // procurar próxima ocorrência
      p1 := Pos(openTag, Work);
    end;
    Result := Work;
  end;
  function SanitizeXmlForDanfe(const OrigXmlPath: string; out OutPath: string): Boolean;
  var
    S: string;
    TempDir: string;
  begin
    Result := False;
    OutPath := '';
    try
      S := TFile.ReadAllText(OrigXmlPath, TEncoding.UTF8);
    except
      Exit;
    end;
    try
      // Corrige <xCpl>null</xCpl>
      S := StringReplace(S, '<xCpl>null</xCpl>', '<xCpl></xCpl>', [rfReplaceAll, rfIgnoreCase]);
      // Trunca campos críticos do layout do DANFE (valores conservadores)
      S := ReplaceTagValueAll(S, 'xNome', 60);
      S := ReplaceTagValueAll(S, 'xFant', 60);
      S := ReplaceTagValueAll(S, 'xLgr', 60);
      S := ReplaceTagValueAll(S, 'xBairro', 40);
      S := ReplaceTagValueAll(S, 'xMun', 40);
      S := ReplaceTagValueAll(S, 'xCpl', 60);
      S := ReplaceTagValueAll(S, 'xProd', 60);
      S := ReplaceTagValueAll(S, 'natOp', 60);
      // Salva XML sanitizado em arquivo temporário
      TempDir := ExtractFilePath(Application.ExeName) + 'logs\requests\';
      try ForceDirectories(TempDir); except end;
      OutPath := TempDir + 'sanitized_' + FormatDateTime('yyyymmdd_hhnnss_zzz', Now) + '.xml';
      TFile.WriteAllText(OutPath, S, TEncoding.UTF8);
      Result := FileExists(OutPath);
    except
      Result := False;
    end;
  end;
begin
  Resp := TJSONObject.Create;
  ComInitialized := Succeeded(CoInitialize(nil));
  try
    try
      J := TJSONObject(TJSONObject.ParseJSONValue(JSONData));
      if not Assigned(J) then
        raise Exception.Create('JSON inválido');

      // Caminho do XML autorizado
      XMLPath := JsonGetStr(J, 'xml_path', '');
      if (XMLPath = '') or (not FileExists(XMLPath)) then
        raise Exception.Create('XML não encontrado em xml_path');

      // Configurações (opcionais)
      Conf := JsonGetObj(J, 'configuracoes');
      if Assigned(Conf) then
      begin
        try GeneratePDF := SameText(Trim(JsonGetStr(Conf, 'gerar_pdf', 'true')), 'true'); except GeneratePDF := True; end;
        EnginePref := UpperCase(Trim(JsonGetStr(Conf, 'engine', '')));
        UseFPDF := EnginePref = 'FPDF';
        // Detecta pedido explícito de tarja CANCELADA
        var WantCancelStripe := False;
        try
          var tarja := Trim(JsonGetStr(Conf, 'tarja_cancelada', ''));
          var canc  := Trim(JsonGetStr(Conf, 'cancelada', ''));
          var stat  := UpperCase(Trim(JsonGetStr(Conf, 'status', '')));
          if SameText(tarja, 'true') then WantCancelStripe := True;
          if (canc = '1') or SameText(canc, 'true') then WantCancelStripe := True;
          if stat = 'CANCELADA' then WantCancelStripe := True;
        except
        end;
        // Logo opcional
        try
          var LogoPath := JsonGetStr(Conf, 'logo_path', '');
          if (LogoPath <> '') and FileExists(LogoPath) then
            try ACBrNFeDANFeRL1.Logo := LogoPath; except end;
        except end;
        // Se houve pedido de tarja e não temos implementação na engine, forçamos fallback no ERP (não retornar PDF)
        // Observação: o ERP já imprime tarja CANCELADA no fallback.
        if WantCancelStripe then
        begin
          try Resp.AddPair('cancel_tarja_requested', TJSONBool.Create(True)); except end;
        end;
      end
      else
      begin
        GeneratePDF := True;
        UseFPDF := False;
      end;

      // Carrega o XML no ACBr (usar versão sanitizada para evitar ERangeError no RL)
      ACBrNFe1.NotasFiscais.Clear;
      var SanPath: string := '';
      var SanApplied: Boolean := False;
      try
        if SanitizeXmlForDanfe(XMLPath, SanPath) and FileExists(SanPath) then
        begin
          ACBrNFe1.NotasFiscais.LoadFromFile(SanPath);
          SanApplied := True;
        end
        else
          ACBrNFe1.NotasFiscais.LoadFromFile(XMLPath);
      except
        on E: Exception do
          raise Exception.Create('Falha ao carregar XML: ' + E.Message);
      end;

      // Pasta de saída do PDF
      PDFDir := 'C:\xampp\htdocs\Emissor\qfiscal\storage\danfe\';
      try ForceDirectories(PDFDir); except end;
      try ACBrNFeDANFeRL1.PathPDF := PDFDir; except end;

      PDFSuccess := False;
      PdfErrorMsg := '';
      if GeneratePDF then
      begin
        // Estratégia agressiva para evitar WIC: configuração mínima
        try
          ACBrNFeDANFeRL1.Logo := '';
          ACBrNFeDANFeRL1.Sistema := '';
          ACBrNFeDANFeRL1.Impressora := '';
          // Força nome de saída previsível
          var Ch := ACBrNFe1.NotasFiscais.Items[0].NFe.infNFe.ID;
        except end;
        if UseFPDF then
        begin
          // Usa somente FPDF (evita RL/ScanLine por completo)
          var OldDanfeFP := ACBrNFe1.DANFE;
          var DanfeFPDF := TACBrNFeDANFeFPDF.Create(nil);
          try
            try DanfeFPDF.PathPDF := PDFDir; except end;
            ACBrNFe1.DANFE := DanfeFPDF;
            ACBrNFe1.NotasFiscais.ImprimirPDF;
            PDFSuccess := True;
          finally
            ACBrNFe1.DANFE := OldDanfeFP;
            DanfeFPDF.Free;
          end;
        end
        else
        begin
          // Tenta RL primeiro, cai para FPDF em caso de erro
          try
            ACBrNFe1.NotasFiscais.ImprimirPDF;
            PDFSuccess := True;
          except
            on E: Exception do
            begin
              PdfErrorMsg := E.Message;
              // Fallback FPDF
              try
                var OldDanfe2 := ACBrNFe1.DANFE;
                var DanfeFPDF2 := TACBrNFeDANFeFPDF.Create(nil);
                try
                  try DanfeFPDF2.PathPDF := PDFDir; except end;
                  ACBrNFe1.DANFE := DanfeFPDF2;
                  ACBrNFe1.NotasFiscais.ImprimirPDF;
                  PDFSuccess := True;
                  PdfErrorMsg := '';
                finally
                  ACBrNFe1.DANFE := OldDanfe2;
                  DanfeFPDF2.Free;
                end;
              except
                // mantém erro em PdfErrorMsg
              end;
            end;
          end;
          if not PDFSuccess then
          begin
            try
              ACBrNFe1.NotasFiscais.Items[0].ImprimirPDF;
              PDFSuccess := True;
            except
              on E2: Exception do
              begin
                if PdfErrorMsg = '' then PdfErrorMsg := E2.Message;
              end;
            end;
          end;
        end;

        // Tenta localizar o PDF gerado
        try
          PDFPath := PDFDir + 'NFe_' + ACBrNFe1.NotasFiscais.Items[0].NFe.infNFe.ID + '.pdf';
          if not FileExists(PDFPath) then
          begin
            // Tentativas alternativas de nome
            var Alt1 := PDFDir + ACBrNFe1.NotasFiscais.Items[0].NFe.infNFe.ID + '.pdf';
            var Ch := ACBrNFe1.NotasFiscais.Items[0].NFe.infNFe.ID;
            var Alt2 := PDFDir + 'DANFE_' + Ch + '.pdf';
            if FileExists(Alt1) then PDFPath := Alt1
            else if FileExists(Alt2) then PDFPath := Alt2
            else
            begin
              var SR: TSearchRec;
              var LastTime: TDateTime := 0;
              var Best: string := '';
              if FindFirst(PDFDir + '*.pdf', faAnyFile, SR) = 0 then
              begin
                repeat
                  // Compatível com Delphi Win32: usa TimeStamp (TDateTime) ao invés de FindData
                  var FTime := SR.TimeStamp;
                  if (Best = '') or (FTime > LastTime) then
                  begin
                    Best := IncludeTrailingPathDelimiter(PDFDir) + SR.Name;
                    LastTime := FTime;
                  end;
                until FindNext(SR) <> 0;
                FindClose(SR);
              end;
              PDFPath := Best;
            end;
          end;
          if (PDFPath <> '') and not FileExists(PDFPath) then PDFPath := '';
        except
          PDFPath := '';
        end;


      Resp.AddPair('ok', TJSONBool.Create(True));
      Resp.AddPair('xml_path', XMLPath);
      Resp.AddPair('pdf_success', TJSONBool.Create(PDFSuccess));
      if PDFPath <> '' then Resp.AddPair('pdf_path', PDFPath);
      if SanApplied and (SanPath <> '') then Resp.AddPair('sanitized_xml_path', SanPath);
      if (not PDFSuccess) and (PdfErrorMsg <> '') then Resp.AddPair('pdf_error', PdfErrorMsg);
      end;
    except
      on E: Exception do
      begin
        Resp.AddPair('ok', TJSONBool.Create(False));
        Resp.AddPair('error', E.Message);
      end;
    end;
    Result := Resp.ToString;
  finally
    if ComInitialized then
      CoUninitialize;
    Resp.Free;
  end;
end;

function TForm1.CancelarNFeJSON(const JSONData: string): string;
var
  J, Conf, Cfg: TJSONObject;
  Resp: TJSONObject;
  xmlPath, chave, justificativa, emitCNPJ, xmlRet, serialTop, pfxPath, pfxPass: string;
  pathSchemas, pathXmlBase: string;
begin
  Resp := TJSONObject.Create;
  try
    try
      J := TJSONObject(TJSONObject.ParseJSONValue(JSONData));
      if not Assigned(J) then
        raise Exception.Create('JSON inválido');

      xmlPath := JsonGetStr(J, 'xml_path', '');
      chave := JsonGetStr(J, 'chave', '');
      justificativa := JsonGetStr(J, 'justificativa', '');
      emitCNPJ := JsonGetStr(J, 'emit_cnpj', '');
      if Length(justificativa) < 15 then
        raise Exception.Create('Justificativa deve ter no mínimo 15 caracteres');

      // Certificado (opcional) — aceita tanto bloco cert quanto campos de topo
      Conf := JsonGetObj(J, 'cert');
      serialTop := JsonGetStr(J, 'serial', '');
      pfxPath := '';
      pfxPass := '';
      if Assigned(Conf) then
      begin
        if JsonGetStr(Conf, 'serial', '') <> '' then
        begin
          ACBrNFe1.Configuracoes.Certificados.NumeroSerie := JsonGetStr(Conf, 'serial', '');
          ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := '';
          ACBrNFe1.Configuracoes.Certificados.Senha := '';
        end
        else
        begin
          pfxPath := JsonGetStr(Conf, 'path', '');
          pfxPass := JsonGetStr(Conf, 'password', '');
          if pfxPath <> '' then
          begin
            ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := AnsiString(pfxPath);
            ACBrNFe1.Configuracoes.Certificados.Senha := AnsiString(pfxPass);
            ACBrNFe1.Configuracoes.Certificados.NumeroSerie := '';
          end;
        end;
      end;
      if (ACBrNFe1.Configuracoes.Certificados.NumeroSerie = '') and (serialTop <> '') then
      begin
        ACBrNFe1.Configuracoes.Certificados.NumeroSerie := serialTop;
        ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := '';
        ACBrNFe1.Configuracoes.Certificados.Senha := '';
      end;

      // Configurações opcionais: path_schemas e path_xml base
      Cfg := JsonGetObj(J, 'configuracoes');
      if Assigned(Cfg) then
      begin
        pathSchemas := JsonGetStr(Cfg, 'path_schemas', '');
        if pathSchemas <> '' then
          ACBrNFe1.Configuracoes.Arquivos.PathSchemas := IncludeTrailingPathDelimiter(pathSchemas);
        pathXmlBase := JsonGetStr(Cfg, 'path_xml', '');
        if pathXmlBase <> '' then
          ACBrNFe1.Configuracoes.Arquivos.PathNFe := IncludeTrailingPathDelimiter(pathXmlBase);
        // Define UF explicitamente quando informado (evita "UF não pode ser vazia")
        var cfgUF := JsonGetStr(Cfg, 'uf', '');
        if cfgUF <> '' then
          ACBrNFe1.Configuracoes.WebServices.UF := cfgUF;
      end;

      ACBrNFe1.NotasFiscais.Clear;
      if xmlPath <> '' then
        ACBrNFe1.NotasFiscais.LoadFromFile(xmlPath);

      ACBrNFe1.EventoNFe.Evento.Clear;
      ACBrNFe1.EventoNFe.idLote := 1;
      with ACBrNFe1.EventoNFe.Evento.New do
      begin
        infEvento.dhEvento := Now;
        // Tipo Cancelamento (teCancelamento)
        infEvento.tpEvento := teCancelamento;
        if chave <> '' then
          infEvento.chNFe := chave;
        if emitCNPJ <> '' then
          infEvento.CNPJ := emitCNPJ;
        infEvento.detEvento.xJust := justificativa;
      end;

      ACBrNFe1.EnviarEvento(1);
      xmlRet := ACBrNFe1.WebServices.EnvEvento.EventoRetorno.XmlRetorno;

      Resp.AddPair('ok', TJSONBool.Create(True));
      if xmlPath <> '' then Resp.AddPair('xml_referencia', xmlPath);
      if chave <> '' then Resp.AddPair('chave', chave);
      Resp.AddPair('xml_retorno', xmlRet);
    except
      on E: Exception do
      begin
        Resp.AddPair('ok', TJSONBool.Create(False));
        Resp.AddPair('error', E.Message);
      end;
    end;
    Result := Resp.ToString;
  finally
    Resp.Free;
  end;
end;

function TForm1.CartaCorrecaoJSON(const JSONData: string): string;
var
  J, Conf, Cfg: TJSONObject;
  Resp: TJSONObject;
  xmlPath, chave, correcao, emitCNPJ, xmlRet, serialTop, pfxPath, pfxPass: string;
  seq: Integer;
  pathSchemas, pathXmlBase: string;
begin
  Resp := TJSONObject.Create;
  try
    try
      J := TJSONObject(TJSONObject.ParseJSONValue(JSONData));
      if not Assigned(J) then
        raise Exception.Create('JSON inválido');

      xmlPath := JsonGetStr(J, 'xml_path', '');
      chave := JsonGetStr(J, 'chave', '');
      correcao := JsonGetStr(J, 'correcao', '');
      emitCNPJ := JsonGetStr(J, 'emit_cnpj', '');
      seq := JsonGetInt(J, 'sequencia', 1);
      if Length(correcao) < 15 then
        raise Exception.Create('Texto da correção deve ter no mínimo 15 caracteres');

      // Certificado (opcional)
      Conf := JsonGetObj(J, 'cert');
      serialTop := JsonGetStr(J, 'serial', '');
      pfxPath := '';
      pfxPass := '';
      if Assigned(Conf) then
      begin
        if JsonGetStr(Conf, 'serial', '') <> '' then
        begin
          ACBrNFe1.Configuracoes.Certificados.NumeroSerie := JsonGetStr(Conf, 'serial', '');
          ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := '';
          ACBrNFe1.Configuracoes.Certificados.Senha := '';
        end
        else
        begin
          pfxPath := JsonGetStr(Conf, 'path', '');
          pfxPass := JsonGetStr(Conf, 'password', '');
          if pfxPath <> '' then
          begin
            ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := AnsiString(pfxPath);
            ACBrNFe1.Configuracoes.Certificados.Senha := AnsiString(pfxPass);
            ACBrNFe1.Configuracoes.Certificados.NumeroSerie := '';
          end;
        end;
      end;
      if (ACBrNFe1.Configuracoes.Certificados.NumeroSerie = '') and (serialTop <> '') then
      begin
        ACBrNFe1.Configuracoes.Certificados.NumeroSerie := serialTop;
        ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := '';
        ACBrNFe1.Configuracoes.Certificados.Senha := '';
      end;

      // Configurações opcionais: path_schemas e path_xml base
      Cfg := JsonGetObj(J, 'configuracoes');
      if Assigned(Cfg) then
      begin
        pathSchemas := JsonGetStr(Cfg, 'path_schemas', '');
        if pathSchemas <> '' then
          ACBrNFe1.Configuracoes.Arquivos.PathSchemas := IncludeTrailingPathDelimiter(pathSchemas);
        pathXmlBase := JsonGetStr(Cfg, 'path_xml', '');
        if pathXmlBase <> '' then
          ACBrNFe1.Configuracoes.Arquivos.PathNFe := IncludeTrailingPathDelimiter(pathXmlBase);
      end;

      ACBrNFe1.NotasFiscais.Clear;
      if xmlPath <> '' then
        ACBrNFe1.NotasFiscais.LoadFromFile(xmlPath);

      ACBrNFe1.EventoNFe.Evento.Clear;
      ACBrNFe1.EventoNFe.idLote := 1;
      with ACBrNFe1.EventoNFe.Evento.New do
      begin
        infEvento.dhEvento := Now;
        // Tipo Carta de Correção (teCCe)
        infEvento.tpEvento := teCCe;
        if chave <> '' then
          infEvento.chNFe := chave;
        if emitCNPJ <> '' then
          infEvento.CNPJ := emitCNPJ;
        infEvento.nSeqEvento := seq;
        infEvento.detEvento.xCorrecao := correcao;
      end;

      ACBrNFe1.EnviarEvento(1);
      xmlRet := ACBrNFe1.WebServices.EnvEvento.EventoRetorno.XmlRetorno;

      Resp.AddPair('ok', TJSONBool.Create(True));
      if xmlPath <> '' then Resp.AddPair('xml_referencia', xmlPath);
      if chave <> '' then Resp.AddPair('chave', chave);
      Resp.AddPair('xml_retorno', xmlRet);
    except
      on E: Exception do
      begin
        Resp.AddPair('ok', TJSONBool.Create(False));
        Resp.AddPair('error', E.Message);
      end;
    end;
    Result := Resp.ToString;
  finally
    Resp.Free;
  end;
end;

function TForm1.JsonGetObj(Obj: TJSONObject; const Key: string): TJSONObject;
var V: TJSONValue;
begin
  Result := nil;
  if not Assigned(Obj) then Exit;
  V := Obj.Values[Key];
  if (V <> nil) and (V is TJSONObject) then
    Result := TJSONObject(V);
end;

function TForm1.JsonGetArr(Obj: TJSONObject; const Key: string): TJSONArray;
var V: TJSONValue;
begin
  Result := nil;
  if not Assigned(Obj) then Exit;
  V := Obj.Values[Key];
  if (V <> nil) and (V is TJSONArray) then
    Result := TJSONArray(V);
end;

function TForm1.JsonGetStr(Obj: TJSONObject; const Key: string; const Default: string): string;
var V: TJSONValue;
begin
  Result := Default;
  if not Assigned(Obj) then Exit;
  V := Obj.Values[Key];
  if (V <> nil) then
    Result := V.Value;
end;

function TForm1.JsonGetInt(Obj: TJSONObject; const Key: string; const Default: Integer): Integer;
var s: string;
begin
  s := JsonGetStr(Obj, Key, IntToStr(Default));
  Result := StrToIntDef(s, Default);
end;

// ===== FUNÇÕES DE SEGURANÇA =====

function TForm1.ValidateToken(ARequestInfo: TIdHTTPRequestInfo): Boolean;
var
  Token: string;
begin
  Result := False;
  
  // Se não há tokens configurados, permite acesso (modo desenvolvimento)
  if FValidTokens.Count = 0 then
  begin
    Result := True;
    Exit;
  end;
  
  Token := ExtractTokenFromHeader(ARequestInfo);
  if Token = '' then Exit;
  
  // Verifica se o token está na lista de tokens válidos
  Result := FValidTokens.IndexOf(Token) >= 0;
end;

function TForm1.ExtractTokenFromHeader(ARequestInfo: TIdHTTPRequestInfo): string;
var
  AuthHeader, XToken: string;
begin
  Result := '';
  // 1) Authorization: Bearer <token>
  AuthHeader := ARequestInfo.RawHeaders.Values['Authorization'];
  if (AuthHeader <> '') and (Pos('Bearer ', AuthHeader) = 1) then
  begin
    Result := Copy(AuthHeader, 8, Length(AuthHeader) - 7);
    Exit;
  end;
  // 2) X-Token: <token>
  XToken := ARequestInfo.RawHeaders.Values['X-Token'];
  if (XToken <> '') then
  begin
    Result := XToken;
    Exit;
  end;
  // 3) ?token=<token>
  if (ARequestInfo.Params.Values['token'] <> '') then
  begin
    Result := ARequestInfo.Params.Values['token'];
    Exit;
  end;
end;

procedure TForm1.LogSecurityEvent(const EventType, Details: string);
var
  LogFile: TextFile;
  LogPath: string;
  DateTimeStr: string;
begin
  try
    // Cria diretório de logs se não existir
    LogPath := ExtractFilePath(Application.ExeName) + 'logs\';
    if not DirectoryExists(LogPath) then
      ForceDirectories(LogPath);
    
    // Nome do arquivo de log com data
    LogPath := LogPath + 'security_' + FormatDateTime('yyyy-mm-dd', Now) + '.log';
    
    // Formata data/hora
    DateTimeStr := FormatDateTime('yyyy-mm-dd hh:nn:ss', Now);
    
    // Escreve no arquivo de log
    AssignFile(LogFile, LogPath);
    if FileExists(LogPath) then
      Append(LogFile)
    else
      Rewrite(LogFile);
    
    try
      Writeln(LogFile, '[' + DateTimeStr + '] ' + EventType + ': ' + Details);
    finally
      CloseFile(LogFile);
    end;
  except
    // Em caso de erro, não interrompe o funcionamento
  end;
end;

procedure TForm1.LoadValidTokens;
var
  ConfigFile: TextFile;
  ConfigPath: string;
  Line: string;
begin
  FValidTokens.Clear;
  
  try
    // Arquivo de configuração de tokens (aceita tokens.txt ou token.txt)
    ConfigPath := ExtractFilePath(Application.ExeName) + 'tokens.txt';
    if not FileExists(ConfigPath) then
      ConfigPath := ExtractFilePath(Application.ExeName) + 'token.txt';
    
    // Somente lê tokens se o arquivo existir.
    // Se não existir, mantém lista vazia → sem exigência de token (modo desenvolvimento/teste).
    if FileExists(ConfigPath) then
    begin
      AssignFile(ConfigFile, ConfigPath);
      Reset(ConfigFile);
      try
        while not Eof(ConfigFile) do
        begin
          Readln(ConfigFile, Line);
          Line := Trim(Line);
          if (Line <> '') and (Pos('#', Line) <> 1) then
            FValidTokens.Add(Line);
        end;
      finally
        CloseFile(ConfigFile);
      end;
    end;
  except
    // Em caso de erro, não altera a lista (permite sem token em desenvolvimento)
  end;
end;

end.
